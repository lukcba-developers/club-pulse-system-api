
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lukcba/club-pulse-system-api/backend/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">github.com/lukcba/club-pulse-system-api/backend/cmd/migrate/main.go (0.0%)</option>
				
				<option value="file2">github.com/lukcba/club-pulse-system-api/backend/cmd/seeder/main.go (0.0%)</option>
				
				<option value="file3">github.com/lukcba/club-pulse-system-api/backend/docs/docs.go (0.0%)</option>
				
				<option value="file4">github.com/lukcba/club-pulse-system-api/backend/internal/bootstrap/app.go (0.0%)</option>
				
				<option value="file5">github.com/lukcba/club-pulse-system-api/backend/internal/bootstrap/database.go (0.0%)</option>
				
				<option value="file6">github.com/lukcba/club-pulse-system-api/backend/internal/bootstrap/server.go (0.0%)</option>
				
				<option value="file7">github.com/lukcba/club-pulse-system-api/backend/internal/core/errors/errors.go (0.0%)</option>
				
				<option value="file8">github.com/lukcba/club-pulse-system-api/backend/internal/modules/access/application/usecase.go (0.0%)</option>
				
				<option value="file9">github.com/lukcba/club-pulse-system-api/backend/internal/modules/access/infrastructure/http/handler.go (0.0%)</option>
				
				<option value="file10">github.com/lukcba/club-pulse-system-api/backend/internal/modules/access/infrastructure/repository/postgres_access.go (0.0%)</option>
				
				<option value="file11">github.com/lukcba/club-pulse-system-api/backend/internal/modules/attendance/application/usecases.go (0.0%)</option>
				
				<option value="file12">github.com/lukcba/club-pulse-system-api/backend/internal/modules/attendance/infrastructure/http/handler.go (0.0%)</option>
				
				<option value="file13">github.com/lukcba/club-pulse-system-api/backend/internal/modules/attendance/infrastructure/repository/postgres_attendance.go (0.0%)</option>
				
				<option value="file14">github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/application/usecases.go (0.0%)</option>
				
				<option value="file15">github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/infrastructure/http/handler.go (17.6%)</option>
				
				<option value="file16">github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/infrastructure/http/middleware.go (0.0%)</option>
				
				<option value="file17">github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/infrastructure/repository/memory.go (0.0%)</option>
				
				<option value="file18">github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/infrastructure/repository/postgres.go (0.0%)</option>
				
				<option value="file19">github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/infrastructure/service/google.go (0.0%)</option>
				
				<option value="file20">github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/infrastructure/session/session_store.go (0.0%)</option>
				
				<option value="file21">github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/infrastructure/token/jwt.go (0.0%)</option>
				
				<option value="file22">github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/application/usecases.go (24.8%)</option>
				
				<option value="file23">github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/infrastructure/cache/reservation_lock.go (0.0%)</option>
				
				<option value="file24">github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/infrastructure/http/handler.go (0.0%)</option>
				
				<option value="file25">github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/infrastructure/lock/booking_lock.go (0.0%)</option>
				
				<option value="file26">github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/infrastructure/repository/postgres.go (0.0%)</option>
				
				<option value="file27">github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/infrastructure/repository/postgres_recurring.go (0.0%)</option>
				
				<option value="file28">github.com/lukcba/club-pulse-system-api/backend/internal/modules/club/application/usecases.go (0.0%)</option>
				
				<option value="file29">github.com/lukcba/club-pulse-system-api/backend/internal/modules/club/infrastructure/http/handler.go (0.0%)</option>
				
				<option value="file30">github.com/lukcba/club-pulse-system-api/backend/internal/modules/club/infrastructure/repository/postgres.go (0.0%)</option>
				
				<option value="file31">github.com/lukcba/club-pulse-system-api/backend/internal/modules/disciplines/application/usecases.go (0.0%)</option>
				
				<option value="file32">github.com/lukcba/club-pulse-system-api/backend/internal/modules/disciplines/infrastructure/http/handler.go (0.0%)</option>
				
				<option value="file33">github.com/lukcba/club-pulse-system-api/backend/internal/modules/disciplines/infrastructure/repository/postgres_championships.go (0.0%)</option>
				
				<option value="file34">github.com/lukcba/club-pulse-system-api/backend/internal/modules/disciplines/infrastructure/repository/postgres_disciplines.go (0.0%)</option>
				
				<option value="file35">github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/application/semantic_search.go (0.0%)</option>
				
				<option value="file36">github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/application/usecases.go (0.0%)</option>
				
				<option value="file37">github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/domain/facility.go (0.0%)</option>
				
				<option value="file38">github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/infrastructure/http/handler.go (0.0%)</option>
				
				<option value="file39">github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/infrastructure/http/search_handler.go (0.0%)</option>
				
				<option value="file40">github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/infrastructure/repository/postgres.go (0.0%)</option>
				
				<option value="file41">github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/application/usecases.go (0.0%)</option>
				
				<option value="file42">github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/domain/membership.go (100.0%)</option>
				
				<option value="file43">github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/domain/subscription.go (0.0%)</option>
				
				<option value="file44">github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/infrastructure/http/handler.go (0.0%)</option>
				
				<option value="file45">github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/infrastructure/repository/postgres.go (0.0%)</option>
				
				<option value="file46">github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/infrastructure/repository/postgres_subscription.go (0.0%)</option>
				
				<option value="file47">github.com/lukcba/club-pulse-system-api/backend/internal/modules/notification/infrastructure/providers/sendgrid.go (0.0%)</option>
				
				<option value="file48">github.com/lukcba/club-pulse-system-api/backend/internal/modules/notification/infrastructure/providers/twilio.go (0.0%)</option>
				
				<option value="file49">github.com/lukcba/club-pulse-system-api/backend/internal/modules/notification/service/notification.go (0.0%)</option>
				
				<option value="file50">github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/infrastructure/gateways/mock_gateway.go (0.0%)</option>
				
				<option value="file51">github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/infrastructure/gateways/mp_gateway.go (0.0%)</option>
				
				<option value="file52">github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/infrastructure/http/handler.go (0.0%)</option>
				
				<option value="file53">github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/infrastructure/repository/postgres_payment.go (0.0%)</option>
				
				<option value="file54">github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/application/usecases.go (0.0%)</option>
				
				<option value="file55">github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/domain/gamification.go (0.0%)</option>
				
				<option value="file56">github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/domain/user.go (100.0%)</option>
				
				<option value="file57">github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/infrastructure/http/handler.go (0.0%)</option>
				
				<option value="file58">github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/infrastructure/repository/postgres.go (0.0%)</option>
				
				<option value="file59">github.com/lukcba/club-pulse-system-api/backend/internal/platform/audit/audit_queue.go (0.0%)</option>
				
				<option value="file60">github.com/lukcba/club-pulse-system-api/backend/internal/platform/database/postgres.go (0.0%)</option>
				
				<option value="file61">github.com/lukcba/club-pulse-system-api/backend/internal/platform/embedding/embedding.go (0.0%)</option>
				
				<option value="file62">github.com/lukcba/club-pulse-system-api/backend/internal/platform/http/middlewares/ratelimit.go (0.0%)</option>
				
				<option value="file63">github.com/lukcba/club-pulse-system-api/backend/internal/platform/http/middlewares/redis_ratelimit.go (0.0%)</option>
				
				<option value="file64">github.com/lukcba/club-pulse-system-api/backend/internal/platform/http/middlewares/security.go (0.0%)</option>
				
				<option value="file65">github.com/lukcba/club-pulse-system-api/backend/internal/platform/logger/logger.go (0.0%)</option>
				
				<option value="file66">github.com/lukcba/club-pulse-system-api/backend/internal/platform/middleware/logging.go (0.0%)</option>
				
				<option value="file67">github.com/lukcba/club-pulse-system-api/backend/internal/platform/middleware/tenancy.go (0.0%)</option>
				
				<option value="file68">github.com/lukcba/club-pulse-system-api/backend/internal/platform/redis/client.go (0.0%)</option>
				
				<option value="file69">github.com/lukcba/club-pulse-system-api/backend/internal/platform/redis/pubsub.go (0.0%)</option>
				
				<option value="file70">github.com/lukcba/club-pulse-system-api/backend/internal/platform/tracing/provider.go (0.0%)</option>
				
				<option value="file71">github.com/lukcba/club-pulse-system-api/backend/internal/platform/websocket/hub.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"

        _ "github.com/lukcba/club-pulse-system-api/backend/docs"
        "github.com/lukcba/club-pulse-system-api/backend/internal/bootstrap"
)

// @title           Club Pulse API
// @version         1.0
// @description     Management API for Club Pulse System.
// @termsOfService  http://swagger.io/terms/

// @contact.name    API Support
// @contact.url     http://www.swagger.io/support
// @contact.email   support@swagger.io

// @license.name    Apache 2.0
// @license.url     http://www.apache.org/licenses/LICENSE-2.0.html

// @host            localhost:8080
// @BasePath        /api/v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization

// @externalDocs.description  OpenAPI
// @externalDocs.url          https://swagger.io/resources/open-api/
func main() <span class="cov0" title="0">{
        app, err := bootstrap.NewApp()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize app: %v", err)
        }</span>

        <span class="cov0" title="0">app.Run()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"
        "os"

        accessDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/access/domain"
        attendanceRepo "github.com/lukcba/club-pulse-system-api/backend/internal/modules/attendance/infrastructure/repository"
        bookingDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/domain"
        disciplineDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/disciplines/domain"
        membershipDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/domain"
        paymentDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/domain"
        "github.com/lukcba/club-pulse-system-api/backend/internal/platform/database"
)

func main() <span class="cov0" title="0">{
        log.Println("Starting Comprehensive Migration...")

        // Default envs for local if not set
        if os.Getenv("DB_HOST") == "" </span><span class="cov0" title="0">{
                os.Setenv("DB_PASSWORD", "pulse_secret")
                os.Setenv("DB_USER", "postgres")
                os.Setenv("DB_NAME", "club_pulse")
                os.Setenv("DB_HOST", "localhost")
                os.Setenv("DB_PORT", "5432")
        }</span>

        <span class="cov0" title="0">database.InitDB()
        db := database.GetDB()

        log.Println("Migrating All Models...")

        err := db.AutoMigrate(
                &amp;membershipDomain.MembershipTier{},
                &amp;membershipDomain.Membership{},
                &amp;bookingDomain.Booking{},
                &amp;paymentDomain.Payment{},
                &amp;accessDomain.AccessLog{},
                &amp;attendanceRepo.AttendanceListModel{},
                &amp;attendanceRepo.AttendanceRecordModel{},
                &amp;disciplineDomain.Discipline{},
                &amp;disciplineDomain.TrainingGroup{},
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Migration failed: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Migration successful!")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "log"
        "os"
        "time"

        "github.com/google/uuid"
        "github.com/lib/pq"
        accessDom "github.com/lukcba/club-pulse-system-api/backend/internal/modules/access/domain"
        attendanceRepo "github.com/lukcba/club-pulse-system-api/backend/internal/modules/attendance/infrastructure/repository"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/domain"
        bookingDom "github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/domain"
        clubDom "github.com/lukcba/club-pulse-system-api/backend/internal/modules/club/domain"
        disciplineDom "github.com/lukcba/club-pulse-system-api/backend/internal/modules/disciplines/domain"
        facilityDom "github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/domain"
        membershipDom "github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/domain"
        paymentDom "github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/domain"
        "github.com/lukcba/club-pulse-system-api/backend/internal/platform/database"
        "github.com/shopspring/decimal"
        "golang.org/x/crypto/bcrypt"

        "gorm.io/gorm"
)

// SeederUser helps us create the full table schema required by all modules
type SeederUser struct {
        ID                string `gorm:"primaryKey"`
        Name              string
        Email             string `gorm:"uniqueIndex"`
        Password          string
        Role              string
        DateOfBirth       *time.Time
        SportsPreferences map[string]interface{} `gorm:"serializer:json"`
        ParentID          *string                `gorm:"index"`
        ClubID            string                 `gorm:"index"`
        GoogleID          string                 `gorm:"index"`
        AvatarURL         string
        CreatedAt         time.Time
        UpdatedAt         time.Time
        DeletedAt         gorm.DeletedAt `gorm:"index"`
}

func (SeederUser) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>

func main() <span class="cov0" title="0">{
        // Initialize DB
        os.Setenv("DB_PASSWORD", "pulse_secret")
        os.Setenv("DB_HOST", "localhost")
        os.Setenv("DB_PORT", "5432")

        database.InitDB()
        db := database.GetDB()

        log.Println("--- Starting Seeder ---")

        // Reset Tables for clean seed (MVP)
        log.Println("Resetting Tables...")
        // Reset Tables logic removed to preserve App Schema

        // Ensure UUID extension exists
        db.Exec("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";")

        if err := db.Migrator().DropTable(
                &amp;SeederUser{},
                &amp;clubDom.Club{},
                &amp;facilityDom.Facility{},
                &amp;membershipDom.MembershipTier{},
                &amp;membershipDom.Membership{},
                &amp;disciplineDom.Discipline{},
                &amp;disciplineDom.TrainingGroup{},
                &amp;bookingDom.Booking{},
                &amp;paymentDom.Payment{},
                &amp;accessDom.AccessLog{},
                &amp;attendanceRepo.AttendanceRecordModel{},
                // Add others if we seed them
        ); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error dropping tables: %v", err)
        }</span>
        <span class="cov0" title="0">if err := db.AutoMigrate(
                &amp;SeederUser{},
                &amp;clubDom.Club{},
                &amp;facilityDom.Facility{},
                &amp;membershipDom.MembershipTier{},
                &amp;membershipDom.Membership{},
                &amp;disciplineDom.Discipline{},
                &amp;disciplineDom.TrainingGroup{},
                &amp;bookingDom.Booking{},
                &amp;paymentDom.Payment{},
                &amp;accessDom.AccessLog{},
                &amp;attendanceRepo.AttendanceRecordModel{},
                // Add others if we seed them
        ); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to automigrate: %v", err)
        }</span>

        // 0. Seed Clubs
        <span class="cov0" title="0">defaultClub := clubDom.Club{
                ID:        "club-alpha",
                Name:      "Club Alpha",
                Domain:    "club-alpha.com",
                Status:    clubDom.ClubStatusActive,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }
        if err := db.FirstOrCreate(&amp;defaultClub, "id = ?", defaultClub.ID).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating club: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Println("Seeded Club: Club Alpha")
        }</span>

        // 1. Seed Users
        <span class="cov0" title="0">hashedPwd, _ := bcrypt.GenerateFromPassword([]byte("admin123"), bcrypt.DefaultCost)
        admin := domain.User{
                ID:        uuid.New().String(),
                Email:     "admin@clubpulse.com",
                Password:  string(hashedPwd),
                Name:      "System Admin",
                Role:      domain.RoleAdmin,
                ClubID:    defaultClub.ID,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        if err := db.Where("email = ?", admin.Email).FirstOrCreate(&amp;admin).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error seeding admin: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Println("Seeded Admin User")
        }</span>

        // 1.2 Seed Super Admin
        <span class="cov0" title="0">superAdmin := domain.User{
                ID:        uuid.New().String(),
                Email:     "superadmin@clubpulse.com",
                Password:  string(hashedPwd), // Same password for MVP convenience
                Name:      "Super Administrator",
                Role:      domain.RoleSuperAdmin,
                ClubID:    "system",
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        if err := db.Where("email = ?", superAdmin.Email).FirstOrCreate(&amp;superAdmin).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error seeding super admin: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Println("Seeded Super Admin User")
        }</span>

        // 1.5 Seed Test User (Member)
        <span class="cov0" title="0">hashedPwdTest, _ := bcrypt.GenerateFromPassword([]byte("password123"), bcrypt.DefaultCost)
        testUser := domain.User{
                ID:        uuid.New().String(),
                Email:     "testuser@example.com",
                Password:  string(hashedPwdTest),
                Name:      "Test User",
                Role:      domain.RoleMember,
                ClubID:    defaultClub.ID,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        if err := db.Where("email = ?", testUser.Email).FirstOrCreate(&amp;testUser).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error seeding test user: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Println("Seeded Test User")
        }</span>

        // 2. Seed Facilities
        <span class="cov0" title="0">surfaceHard := "Hard Court"
        surfaceTurf := "Artificial Turf"

        facilities := []facilityDom.Facility{
                {
                        ID:         uuid.New().String(),
                        ClubID:     defaultClub.ID, // Add ClubID
                        Name:       "Centre Court (Tennis)",
                        Type:       facilityDom.FacilityTypeCourt,
                        Status:     facilityDom.FacilityStatusActive,
                        HourlyRate: 50.00,
                        Capacity:   4,
                        Location: facilityDom.Location{
                                Name:        "Main Complex",
                                Description: "North Wing",
                        },
                        Specifications: facilityDom.Specifications{
                                SurfaceType: &amp;surfaceHard,
                                Lighting:    true,
                                Covered:     false,
                        },
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
                {
                        ID:         uuid.New().String(),
                        ClubID:     defaultClub.ID, // Add ClubID
                        Name:       "Padel Court 1",
                        Type:       facilityDom.FacilityTypeCourt, // Padel is a court type
                        Status:     facilityDom.FacilityStatusActive,
                        HourlyRate: 35.00,
                        Capacity:   4,
                        Location: facilityDom.Location{
                                Name:        "Padel Zone",
                                Description: "South Wing",
                        },
                        Specifications: facilityDom.Specifications{
                                SurfaceType: &amp;surfaceTurf,
                                Lighting:    true,
                                Covered:     true, // Glass
                        },
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
                {
                        ID:         uuid.New().String(),
                        ClubID:     defaultClub.ID, // Add ClubID
                        Name:       "Main Gym",
                        Type:       facilityDom.FacilityTypeGym,
                        Status:     facilityDom.FacilityStatusActive,
                        HourlyRate: 10.00,
                        Capacity:   50,
                        Location: facilityDom.Location{
                                Name:        "Fitness Building",
                                Description: "Floor 1",
                        },
                        Specifications: facilityDom.Specifications{
                                // Gym might not have surface type relevant here, leaving defaults
                                Lighting: true,
                                Covered:  true,
                        },
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
        }

        for _, f := range facilities </span><span class="cov0" title="0">{
                if err := db.FirstOrCreate(&amp;f, "name = ?", f.Name).Error; err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error seeding facility %s: %v", f.Name, err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Seeded Facility: %s", f.Name)
                }</span>
        }

        // 3. Seed Membership Tiers
        <span class="cov0" title="0">tiers := []membershipDom.MembershipTier{
                {
                        ID:          uuid.New(),
                        ClubID:      defaultClub.ID, // Add ClubID
                        Name:        "Bronze",
                        Description: "Entry level access for casual players",
                        MonthlyFee:  decimal.NewFromFloat(29.99),
                        Colors:      "bg-amber-100 text-amber-800",
                        Benefits:    pq.StringArray{"Access to Gym", "10% Off Court Booking"},
                        IsActive:    true,
                },
                {
                        ID:          uuid.New(),
                        ClubID:      defaultClub.ID, // Add ClubID
                        Name:        "Silver",
                        Description: "Perfect for regular members",
                        MonthlyFee:  decimal.NewFromFloat(59.99),
                        Colors:      "bg-slate-200 text-slate-800",
                        Benefits:    pq.StringArray{"Access to Gym", "Unlimited Sauna", "20% Off Court Booking", "1 Free Guest Pass/mo"},
                        IsActive:    true,
                },
                {
                        ID:          uuid.New(),
                        ClubID:      defaultClub.ID, // Add ClubID
                        Name:        "Gold",
                        Description: "The ultimate VIP experience",
                        MonthlyFee:  decimal.NewFromFloat(99.99),
                        Colors:      "bg-yellow-100 text-yellow-800",
                        Benefits:    pq.StringArray{"All Facilities Access", "Priority Booking", "Free Court Rentals (Off-peak)", "5 Free Guest Passes/mo"},
                        IsActive:    true,
                },
        }

        for _, t := range tiers </span><span class="cov0" title="0">{
                if err := db.FirstOrCreate(&amp;t, "name = ?", t.Name).Error; err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error seeding tier %s: %v", t.Name, err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Seeded Tier: %s", t.Name)
                }</span>
        }

        // 4. Seed Disciplines
        <span class="cov0" title="0">futbol := disciplineDom.Discipline{
                ID:          uuid.New(),
                ClubID:      defaultClub.ID, // Add ClubID
                Name:        "Fútbol",
                Description: "Escuela de fútbol infantil y juvenil",
                IsActive:    true,
        }
        if err := db.FirstOrCreate(&amp;futbol, "name = ?", futbol.Name).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating discipline %s: %v", futbol.Name, err)
        }</span>

        <span class="cov0" title="0">tennis := disciplineDom.Discipline{
                ID:          uuid.New(),
                ClubID:      defaultClub.ID, // Add ClubID
                Name:        "Tenis",
                Description: "Clases grupales e individuales",
                IsActive:    true,
        }
        if err := db.FirstOrCreate(&amp;tennis, "name = ?", tennis.Name).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating discipline %s: %v", tennis.Name, err)
        }</span>

        // 5. Seed Training Groups
        <span class="cov0" title="0">groups := []disciplineDom.TrainingGroup{
                {
                        ID:           uuid.New(),
                        ClubID:       defaultClub.ID, // Add ClubID
                        Name:         "Fútbol 2012",
                        DisciplineID: futbol.ID,
                        Category:     "2012",
                        CoachID:      admin.ID,
                        Schedule:     "Lun/Mie 18:00",
                },
                {
                        ID:           uuid.New(),
                        ClubID:       defaultClub.ID, // Add ClubID
                        Name:         "Fútbol 2015",
                        DisciplineID: futbol.ID,
                        Category:     "2015",
                        CoachID:      admin.ID,
                        Schedule:     "Mar/Jue 17:30",
                },
                {
                        ID:           uuid.New(),
                        ClubID:       defaultClub.ID, // Add ClubID
                        Name:         "Tenis Inicial - Niños",
                        DisciplineID: tennis.ID,
                        Category:     "2014",
                        CoachID:      admin.ID,
                        Schedule:     "Sab 10:00",
                },
        }

        for _, g := range groups </span><span class="cov0" title="0">{
                if err := db.FirstOrCreate(&amp;g, "name = ?", g.Name).Error; err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error seeding group %s: %v", g.Name, err)
                }</span>
        }

        <span class="cov0" title="0">log.Println("Seeded Disciplines and Training Groups")

        log.Println("--- Seeding Completed Successfully ---")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://www.swagger.io/support",
            "email": "support@swagger.io"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Authenticate user and return HttpOnly cookies",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Login user",
                "parameters": [
                    {
                        "description": "Login Credentials",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/application.LoginDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "message: Login successful",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/clubs": {
            "get": {
                "description": "Lists all tenants",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "clubs"
                ],
                "summary": "List all clubs (Super Admin only)",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/domain.Club"
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Creates a new tenant",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "clubs"
                ],
                "summary": "Create a new club (Super Admin only)",
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/domain.Club"
                        }
                    }
                }
            }
        },
        "/clubs/{id}": {
            "put": {
                "description": "Updates tenant details",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "clubs"
                ],
                "summary": "Update a club (Super Admin only)",
                "responses": {}
            }
        },
        "/facilities": {
            "get": {
                "description": "Get a list of facilities for the authenticated club",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "facilities"
                ],
                "summary": "List facilities",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Offset",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/domain.Facility"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/facilities/embeddings/generate": {
            "post": {
                "description": "Batch operation to generate and store embeddings for all facilities",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Facilities"
                ],
                "summary": "Generate embeddings for all facilities",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/facilities/search": {
            "get": {
                "description": "Search for facilities using semantic similarity (e.g., \"canchas para lluvia\", \"piscina nocturna\")",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Facilities"
                ],
                "summary": "Search facilities using natural language",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Search query in natural language",
                        "name": "q",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Maximum results (default 10)",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/application.SemanticSearchResult"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "application.LoginDTO": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "application.SemanticSearchResult": {
            "type": "object",
            "properties": {
                "facility": {
                    "$ref": "#/definitions/domain.Facility"
                },
                "similarity": {
                    "type": "number"
                }
            }
        },
        "domain.Club": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "domain": {
                    "type": "string"
                },
                "id": {
                    "description": "Custom ID (slug) or UUID",
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "settings": {
                    "description": "JSON settings",
                    "type": "string"
                },
                "status": {
                    "$ref": "#/definitions/domain.ClubStatus"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "domain.ClubStatus": {
            "type": "string",
            "enum": [
                "ACTIVE",
                "INACTIVE"
            ],
            "x-enum-varnames": [
                "ClubStatusActive",
                "ClubStatusInactive"
            ]
        },
        "domain.Facility": {
            "type": "object",
            "properties": {
                "capacity": {
                    "type": "integer"
                },
                "club_id": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "hourly_rate": {
                    "type": "number"
                },
                "id": {
                    "type": "string"
                },
                "location": {
                    "description": "Stored as JSONB",
                    "allOf": [
                        {
                            "$ref": "#/definitions/domain.Location"
                        }
                    ]
                },
                "name": {
                    "type": "string"
                },
                "specifications": {
                    "description": "Stored as JSONB",
                    "allOf": [
                        {
                            "$ref": "#/definitions/domain.Specifications"
                        }
                    ]
                },
                "status": {
                    "$ref": "#/definitions/domain.FacilityStatus"
                },
                "type": {
                    "$ref": "#/definitions/domain.FacilityType"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "domain.FacilityStatus": {
            "type": "string",
            "enum": [
                "active",
                "maintenance",
                "closed"
            ],
            "x-enum-varnames": [
                "FacilityStatusActive",
                "FacilityStatusMaintenance",
                "FacilityStatusClosed"
            ]
        },
        "domain.FacilityType": {
            "type": "string",
            "enum": [
                "court",
                "pool",
                "gym",
                "field"
            ],
            "x-enum-varnames": [
                "FacilityTypeCourt",
                "FacilityTypePool",
                "FacilityTypeGym",
                "FacilityTypeField"
            ]
        },
        "domain.Location": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "name": {
                    "description": "e.g. \"Main Building\"",
                    "type": "string"
                }
            }
        },
        "domain.Specifications": {
            "type": "object",
            "properties": {
                "covered": {
                    "type": "boolean"
                },
                "equipment": {
                    "description": "Basic inventory list",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "lighting": {
                    "type": "boolean"
                },
                "surface_type": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    },
    "externalDocs": {
        "description": "OpenAPI",
        "url": "https://swagger.io/resources/open-api/"
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Club Pulse API",
        Description:      "Management API for Club Pulse System.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package bootstrap

import (
        "context"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/lukcba/club-pulse-system-api/backend/internal/platform/logger"
        "github.com/lukcba/club-pulse-system-api/backend/internal/platform/middleware"

        // Module Imports
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/application"
        authHttp "github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/infrastructure/http"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/infrastructure/repository"
        authService "github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/infrastructure/service"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/infrastructure/token"

        userApp "github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/application"
        userHttp "github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/infrastructure/http"
        userRepo "github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/infrastructure/repository"

        facilityApp "github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/application"
        facilitiesHTTP "github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/infrastructure/http"
        facilitiesRepo "github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/infrastructure/repository"

        membershipApplication "github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/application"
        membershipHTTP "github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/infrastructure/http"
        membershipRepo "github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/infrastructure/repository"

        bookingApplication "github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/application"
        bookingHTTP "github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/infrastructure/http"
        bookingRepo "github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/infrastructure/repository"

        accessApp "github.com/lukcba/club-pulse-system-api/backend/internal/modules/access/application"
        accessHTTP "github.com/lukcba/club-pulse-system-api/backend/internal/modules/access/infrastructure/http"
        accessRepo "github.com/lukcba/club-pulse-system-api/backend/internal/modules/access/infrastructure/repository"

        attendanceApp "github.com/lukcba/club-pulse-system-api/backend/internal/modules/attendance/application"
        attendanceHTTP "github.com/lukcba/club-pulse-system-api/backend/internal/modules/attendance/infrastructure/http"
        attendanceRepo "github.com/lukcba/club-pulse-system-api/backend/internal/modules/attendance/infrastructure/repository"

        disciplineApp "github.com/lukcba/club-pulse-system-api/backend/internal/modules/disciplines/application"
        disciplineHttp "github.com/lukcba/club-pulse-system-api/backend/internal/modules/disciplines/infrastructure/http"
        disciplineRepo "github.com/lukcba/club-pulse-system-api/backend/internal/modules/disciplines/infrastructure/repository"

        paymentGateway "github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/infrastructure/gateways"
        paymentHttp "github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/infrastructure/http"
        paymentRepo "github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/infrastructure/repository"

        notificationProviders "github.com/lukcba/club-pulse-system-api/backend/internal/modules/notification/infrastructure/providers"
        notificationService "github.com/lukcba/club-pulse-system-api/backend/internal/modules/notification/service"

        clubApp "github.com/lukcba/club-pulse-system-api/backend/internal/modules/club/application"
        clubHttp "github.com/lukcba/club-pulse-system-api/backend/internal/modules/club/infrastructure/http"
        clubRepo "github.com/lukcba/club-pulse-system-api/backend/internal/modules/club/infrastructure/repository"
)

type App struct {
        Infrastructure *Infrastructure
        Server         *Server
}

func NewApp() (*App, error) <span class="cov0" title="0">{
        // 1. Init Infrastructure (DB, Redis, Logs)
        logger.InitLogger()
        logger.Info("Starting Club Pulse System API v2.0 (High Performance Edition - Refactored)...")

        infra, err := InitInfrastructure()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 2. Init Server
        <span class="cov0" title="0">server := NewServer()

        // 3. Setup Health Check (Basic) - We can move this to a module if it grows
        server.Engine.GET("/health", healthCheckHandler(infra))

        // 4. Register Modules
        v1 := server.Engine.Group("/api/v1")

        // We need clubRepo for Middleware
        // Initialize it early or restructure.
        clubRepository := clubRepo.NewPostgresClubRepository(infra.DB)

        // Middleware Instantiation
        // REMOVED GLOBAL USAGE: v1.Use(middleware.TenantMiddleware(clubRepository))
        // Instead, we will pass it to modules that need it, to be applied AFTER Auth.
        tenantMiddleware := middleware.TenantMiddleware(clubRepository)

        registerModules(v1, infra, tenantMiddleware)

        return &amp;App{
                Infrastructure: infra,
                Server:         server,
        }, nil</span>
}

func (app *App) Run() <span class="cov0" title="0">{
        app.Server.Start()

        // Graceful Shutdown
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        logger.Info("Shutting down server...")

        app.Infrastructure.Shutdown()

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := app.Server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("Server forced to shutdown: " + err.Error())
        }</span>

        <span class="cov0" title="0">logger.Info("Server exited properly")</span>
}

func registerModules(api *gin.RouterGroup, infra *Infrastructure, tenantMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        db := infra.DB

        // --- Module: Auth ---
        authRepo := repository.NewPostgresAuthRepository(db)
        jwtSecret := os.Getenv("JWT_SECRET")
        if jwtSecret == "" </span><span class="cov0" title="0">{
                jwtSecret = "SECRET_KEY_DEV"
        }</span>
        <span class="cov0" title="0">tokenService := token.NewJWTService(jwtSecret)
        googleAuthService := authService.NewGoogleAuthService()
        authUseCase := application.NewAuthUseCases(authRepo, tokenService, googleAuthService)
        authHandler := authHttp.NewAuthHandler(authUseCase)
        authMiddleware := authHttp.AuthMiddleware(tokenService)

        authHttp.RegisterRoutes(api, authHandler, authMiddleware)

        // --- Module: User ---
        userRepository := userRepo.NewPostgresUserRepository(db)
        userUseCase := userApp.NewUserUseCases(userRepository)
        userHandler := userHttp.NewUserHandler(userUseCase)

        userHttp.RegisterRoutes(api, userHandler, authMiddleware, tenantMiddleware)

        // --- Module: Facilities ---
        facilityRepository := facilitiesRepo.NewPostgresFacilityRepository(db)
        facilityUseCase := facilityApp.NewFacilityUseCases(facilityRepository)
        facilityHandler := facilitiesHTTP.NewFacilityHandler(facilityUseCase)

        facilitiesHTTP.RegisterRoutes(api, facilityHandler, authMiddleware, tenantMiddleware)

        // --- Semantic Search (Facilities) ---
        semanticSearchUseCase := facilityApp.NewSemanticSearchUseCase(facilityRepository)
        searchHandler := facilitiesHTTP.NewSearchHandler(semanticSearchUseCase)
        facilitiesHTTP.RegisterSearchRoutes(api, searchHandler)
        logger.Info("Semantic search enabled for facilities")

        // --- Module: Membership ---
        membershipRepository := membershipRepo.NewPostgresMembershipRepository(db)
        membershipUseCase := membershipApplication.NewMembershipUseCases(membershipRepository)
        membershipHandler := membershipHTTP.NewMembershipHandler(membershipUseCase)

        membershipHTTP.RegisterRoutes(api, membershipHandler, authMiddleware, tenantMiddleware)

        // --- Module: Notification (Real Providers) ---
        var emailProvider notificationService.EmailProvider
        if mt := os.Getenv("SENDGRID_API_KEY"); mt != "" </span><span class="cov0" title="0">{
                emailProvider = notificationProviders.NewSendGridProvider(mt, os.Getenv("SENDGRID_FROM_NAME"), os.Getenv("SENDGRID_FROM_EMAIL"))
                logger.Info("SendGrid Email Provider enabled")
        }</span>

        <span class="cov0" title="0">var smsProvider notificationService.SMSProvider
        if ts := os.Getenv("TWILIO_ACCOUNT_SID"); ts != "" </span><span class="cov0" title="0">{
                smsProvider = notificationProviders.NewTwilioProvider(ts, os.Getenv("TWILIO_AUTH_TOKEN"), os.Getenv("TWILIO_FROM_NUMBER"))
                logger.Info("Twilio SMS Provider enabled")
        }</span>

        <span class="cov0" title="0">notifier := notificationService.NewNotificationService(emailProvider, smsProvider)

        // --- Module: Booking ---
        bookingRepository := bookingRepo.NewPostgresBookingRepository(db)
        recurringRepository := bookingRepo.NewPostgresRecurringRepository(db)
        bookingUseCase := bookingApplication.NewBookingUseCases(bookingRepository, recurringRepository, facilityRepository, notifier)
        bookingHandler := bookingHTTP.NewBookingHandler(bookingUseCase)

        bookingHTTP.RegisterRoutes(api, bookingHandler, authMiddleware, tenantMiddleware)

        // --- Module: Access (New) ---
        accessRepository := accessRepo.NewPostgresAccessRepository(db)
        accessUseCase := accessApp.NewAccessUseCases(accessRepository, userRepository, membershipRepository)
        accessHandler := accessHTTP.NewAccessHandler(accessUseCase)

        accessHTTP.RegisterRoutes(api, accessHandler, authMiddleware, tenantMiddleware)

        // --- Module: Attendance (New) ---
        attendanceRepository := attendanceRepo.NewPostgresAttendanceRepository(db)
        attendanceUseCase := attendanceApp.NewAttendanceUseCases(attendanceRepository, userRepository, membershipRepository)
        attendanceHandler := attendanceHTTP.NewAttendanceHandler(attendanceUseCase)

        attendanceHTTP.RegisterRoutes(api, attendanceHandler, authMiddleware, tenantMiddleware)

        // --- Module: Disciplines (New) ---
        dRepo := disciplineRepo.NewPostgresDisciplineRepository(db)
        tRepo := disciplineRepo.NewPostgresTournamentRepository(db)
        dUseCase := disciplineApp.NewDisciplineUseCases(dRepo, tRepo, userRepository)
        dHandler := disciplineHttp.NewDisciplineHandler(dUseCase)

        disciplineHttp.RegisterRoutes(api, dHandler, authMiddleware, tenantMiddleware)

        // --- Module: Payment ---
        paymentRepo := paymentRepo.NewPostgresPaymentRepository(db)
        paymentProc := paymentGateway.NewMercadoPagoGateway()
        paymentHandler := paymentHttp.NewPaymentHandler(paymentRepo, paymentProc)
        paymentHttp.RegisterRoutes(api, paymentHandler, authMiddleware, tenantMiddleware)

        // --- Module: Club (Super Admin) ---
        clubRepository := clubRepo.NewPostgresClubRepository(db)
        clubUseCase := clubApp.NewClubUseCases(clubRepository)
        clubHandler := clubHttp.NewClubHandler(clubUseCase)

        // Register Club Routes
        clubHttp.RegisterRoutes(api, clubHandler, authMiddleware, tenantMiddleware)</span>
}

func healthCheckHandler(infra *Infrastructure) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Check Redis
                redisStatus := "UP"
                if err := infra.Redis.Ping(context.Background()); err != nil </span><span class="cov0" title="0">{
                        redisStatus = "DOWN"
                }</span>

                // Check DB
                <span class="cov0" title="0">dbStatus := "UP"
                sqlDB, err := infra.DB.DB()
                if err != nil || sqlDB.Ping() != nil </span><span class="cov0" title="0">{
                        dbStatus = "DOWN"
                }</span>

                <span class="cov0" title="0">status := "UP"
                if redisStatus == "DOWN" || dbStatus == "DOWN" </span><span class="cov0" title="0">{
                        status = "DEGRADED"
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "status":  status,
                        "system":  "club-pulse-backend",
                        "version": "2.0.0",
                        "services": gin.H{
                                "database": dbStatus,
                                "redis":    redisStatus,
                        },
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package bootstrap

import (
        "fmt"
        "time"

        "github.com/lukcba/club-pulse-system-api/backend/internal/platform/audit"
        "github.com/lukcba/club-pulse-system-api/backend/internal/platform/database"
        "github.com/lukcba/club-pulse-system-api/backend/internal/platform/logger"
        platformRedis "github.com/lukcba/club-pulse-system-api/backend/internal/platform/redis"

        // Domains for migration (only if strictly necessary to keep AutoMigrate for now, generally we'd move this)

        bookingDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/domain"
        paymentDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/domain"

        "gorm.io/gorm"
)

type Infrastructure struct {
        DB         *gorm.DB
        Redis      *platformRedis.RedisClient
        AuditQueue *audit.AuditQueue
}

func InitInfrastructure() (*Infrastructure, error) <span class="cov0" title="0">{
        // 1. Initialize Database
        database.InitDB()
        db := database.GetDB()

        // 2. Initialize Redis
        platformRedis.InitRedis()
        redisClient := platformRedis.GetClient()
        logger.Info("Redis client initialized")

        // 3. Initialize Audit Queue
        // Using a 5-minute flush interval as per previous configuration
        auditQueue := audit.NewAuditQueue(db, 5*time.Minute)
        auditQueue.StartFlushWorker()
        logger.Info("Audit queue worker started (flush every 5 min)")

        // 4. Run basic AutoMigrate (Ideally this should be separate, but keeping parity for now)
        // We only migrate Payment here because it was explicitly in main.go
        if err := db.AutoMigrate(&amp;paymentDomain.Payment{}); err != nil </span><span class="cov0" title="0">{
                logger.Error(fmt.Sprintf("Failed to migrate payment table: %v", err))
        }</span>
        <span class="cov0" title="0">if err := db.AutoMigrate(&amp;bookingDomain.RecurringRule{}); err != nil </span><span class="cov0" title="0">{
                logger.Error(fmt.Sprintf("Failed to migrate recurring_rule table: %v", err))
        }</span>

        <span class="cov0" title="0">return &amp;Infrastructure{
                DB:         db,
                Redis:      redisClient,
                AuditQueue: auditQueue,
        }, nil</span>
}

func (i *Infrastructure) Shutdown() <span class="cov0" title="0">{
        if i.AuditQueue != nil </span><span class="cov0" title="0">{
                i.AuditQueue.Stop()
        }</span>
        // Close DB/Redis connections if necessary (GORM manages pool, Redis client has Close)
        <span class="cov0" title="0">if i.Redis != nil </span><span class="cov0" title="0">{
                i.Redis.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package bootstrap

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/lukcba/club-pulse-system-api/backend/internal/platform/database"
        "github.com/lukcba/club-pulse-system-api/backend/internal/platform/http/middlewares"
        "github.com/lukcba/club-pulse-system-api/backend/internal/platform/logger"
        "github.com/lukcba/club-pulse-system-api/backend/internal/platform/middleware"
        platformRedis "github.com/lukcba/club-pulse-system-api/backend/internal/platform/redis"
        "github.com/lukcba/club-pulse-system-api/backend/internal/platform/tracing"
        "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
        "go.opentelemetry.io/otel/sdk/trace"

        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

type Server struct {
        Engine         *gin.Engine
        srv            *http.Server
        Port           string
        TracerProvider *trace.TracerProvider
}

func NewServer() *Server <span class="cov0" title="0">{
        // Init Tracing
        tp, err := tracing.InitTracer("club-pulse-backend")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(fmt.Sprintf("Failed to init tracer: %v", err))
                // We can continue without tracing or fatal exit. Let's log and continue for now.
        }</span>

        // Initialize Router
        <span class="cov0" title="0">router := gin.New()

        // Register Global Middlewares
        router.Use(gin.Recovery())

        // OpenTelemetry Middleware (Must be first to capture everything)
        router.Use(otelgin.Middleware("club-pulse-backend"))

        router.Use(middlewares.SecurityHeadersMiddleware())
        router.Use(middlewares.CORSMiddleware())

        // Swagger UI
        router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        // Redis Rate Limiting
        middlewares.InitRedisRateLimiter(100, time.Minute) // 100 req/min
        router.Use(middlewares.RedisRateLimitMiddleware())

        // Health Check
        router.GET("/healthz", func(c *gin.Context) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(c.Request.Context(), 2*time.Second)
                defer cancel()

                status := gin.H{
                        "status":    "ok",
                        "timestamp": time.Now(),
                        "services": gin.H{
                                "database": "ok",
                                "redis":    "ok",
                        },
                }
                httpStatus := http.StatusOK

                // Check DB
                db := database.GetDB()
                if db == nil </span><span class="cov0" title="0">{
                        status["status"] = "error"
                        status["services"].(gin.H)["database"] = "connection_is_nil"
                        httpStatus = http.StatusServiceUnavailable
                }</span> else<span class="cov0" title="0"> {
                        sqlDB, err := db.DB()
                        if err != nil || sqlDB.Ping() != nil </span><span class="cov0" title="0">{
                                status["status"] = "error"
                                status["services"].(gin.H)["database"] = "unreachable"
                                httpStatus = http.StatusServiceUnavailable
                        }</span>
                }

                // Check Redis
                <span class="cov0" title="0">rdb := platformRedis.GetClient()
                if rdb == nil </span><span class="cov0" title="0">{
                        status["services"].(gin.H)["redis"] = "connection_is_nil"
                        // Redis failure might be non-critical for basic API (partial degradation), but for "Healthz" (Liveness) it usually means unhealthy.
                        // Let's mark as error.
                        status["status"] = "error"
                        httpStatus = http.StatusServiceUnavailable
                }</span> else<span class="cov0" title="0"> {
                        if err := rdb.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                                status["services"].(gin.H)["redis"] = "unreachable"
                                status["status"] = "error"
                                httpStatus = http.StatusServiceUnavailable
                        }</span>
                }

                <span class="cov0" title="0">c.JSON(httpStatus, status)</span>
        })

        <span class="cov0" title="0">router.Use(middleware.StructuredLogger())

        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        <span class="cov0" title="0">return &amp;Server{
                Engine:         router,
                Port:           port,
                TracerProvider: tp,
        }</span>
}

func (s *Server) Start() <span class="cov0" title="0">{
        s.srv = &amp;http.Server{
                Addr:    ":" + s.Port,
                Handler: s.Engine,
        }

        go func() </span><span class="cov0" title="0">{
                logger.Info(fmt.Sprintf("Server listening on port %s", s.Port))
                if err := s.srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Failed to start server: %v", err))
                        os.Exit(1)
                }</span>
        }()
}

func (s *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        logger.Info("Shutting down server...")

        // Flush Traces
        if s.TracerProvider != nil </span><span class="cov0" title="0">{
                if err := s.TracerProvider.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error shutting down tracer provider: %v", err))
                }</span>
        }

        <span class="cov0" title="0">return s.srv.Shutdown(ctx)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package errors

import (
        "fmt"
        "net/http"
)

// ErrorType identifies the kind of error
type ErrorType string

const (
        ErrorTypeValidation    ErrorType = "VALIDATION_ERROR"
        ErrorTypeNotFound      ErrorType = "NOT_FOUND"
        ErrorTypeUnauthorized  ErrorType = "UNAUTHORIZED"
        ErrorTypeForbidden     ErrorType = "FORBIDDEN"
        ErrorTypeInternal      ErrorType = "INTERNAL_SERVER_ERROR"
        ErrorTypeConflict      ErrorType = "CONFLICT"
)

// AppError is the standard error struct for the application
type AppError struct {
        Type    ErrorType `json:"type"`
        Message string    `json:"message"`
        Code    int       `json:"code"`
        Err     error     `json:"-"` // Internal error for logging
}

func (e *AppError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("[%s] %s", e.Type, e.Message)
}</span>

func New(errType ErrorType, msg string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Type:    errType,
                Message: msg,
                Code:    mapTypeToStatusCode(errType),
        }
}</span>

func Wrap(errType ErrorType, msg string, err error) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Type:    errType,
                Message: msg,
                Code:    mapTypeToStatusCode(errType),
                Err:     err,
        }
}</span>

// Validation helper (e.g. for creating validation error details)
func NewValidation(msg string) *AppError <span class="cov0" title="0">{
        return New(ErrorTypeValidation, msg)
}</span>

func mapTypeToStatusCode(t ErrorType) int <span class="cov0" title="0">{
        switch t </span>{
        case ErrorTypeValidation:<span class="cov0" title="0">
                return http.StatusBadRequest</span>
        case ErrorTypeNotFound:<span class="cov0" title="0">
                return http.StatusNotFound</span>
        case ErrorTypeUnauthorized:<span class="cov0" title="0">
                return http.StatusUnauthorized</span>
        case ErrorTypeForbidden:<span class="cov0" title="0">
                return http.StatusForbidden</span>
        case ErrorTypeConflict:<span class="cov0" title="0">
                return http.StatusConflict</span>
        default:<span class="cov0" title="0">
                return http.StatusInternalServerError</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package application

import (
        "context"
        "errors"
        "time"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/access/domain"
        membershipDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/domain"
        userDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/domain"
)

type AccessUseCases struct {
        accessRepo     domain.AccessRepository
        userRepo       userDomain.UserRepository
        membershipRepo membershipDomain.MembershipRepository
}

func NewAccessUseCases(
        accessRepo domain.AccessRepository,
        userRepo userDomain.UserRepository,
        membershipRepo membershipDomain.MembershipRepository,
) *AccessUseCases <span class="cov0" title="0">{
        return &amp;AccessUseCases{
                accessRepo:     accessRepo,
                userRepo:       userRepo,
                membershipRepo: membershipRepo,
        }
}</span>

type EntryRequest struct {
        UserID     string     `json:"user_id"`
        FacilityID *uuid.UUID `json:"facility_id"`
        Direction  string     `json:"direction"` // IN, OUT
}

func (uc *AccessUseCases) RequestEntry(ctx context.Context, clubID string, req EntryRequest) (*domain.AccessLog, error) <span class="cov0" title="0">{
        // 1. Validate Input
        if req.UserID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("user_id required")
        }</span>

        // 2. Validate User Exists
        <span class="cov0" title="0">user, err := uc.userRepo.GetByID(clubID, req.UserID)
        if err != nil || user == nil </span><span class="cov0" title="0">{
                return uc.logAccess(ctx, clubID, req, domain.AccessStatusDenied, "User not found")
        }</span>

        // 3. For Entry (IN), validate Membership
        <span class="cov0" title="0">if req.Direction == "IN" || req.Direction == "" </span><span class="cov0" title="0">{
                // Convert String ID to UUID for Membership Repo
                userUUID, err := uuid.Parse(req.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return uc.logAccess(ctx, clubID, req, domain.AccessStatusDenied, "Invalid User ID format")
                }</span>

                <span class="cov0" title="0">memberships, err := uc.membershipRepo.GetByUserID(ctx, clubID, userUUID)
                if err != nil </span><span class="cov0" title="0">{
                        return uc.logAccess(ctx, clubID, req, domain.AccessStatusDenied, "Error fetching memberships")
                }</span>

                <span class="cov0" title="0">hasActive := false
                hasDebt := false

                for _, m := range memberships </span><span class="cov0" title="0">{
                        if m.Status == membershipDomain.MembershipStatusActive </span><span class="cov0" title="0">{
                                hasActive = true
                                if m.OutstandingBalance.IsPositive() </span><span class="cov0" title="0">{
                                        hasDebt = true
                                }</span>
                        }
                }

                <span class="cov0" title="0">if !hasActive </span><span class="cov0" title="0">{
                        return uc.logAccess(ctx, clubID, req, domain.AccessStatusDenied, "No active membership")
                }</span>
                <span class="cov0" title="0">if hasDebt </span><span class="cov0" title="0">{
                        return uc.logAccess(ctx, clubID, req, domain.AccessStatusDenied, "Outstanding debt")
                }</span>
        }

        // 4. Grant Access
        <span class="cov0" title="0">return uc.logAccess(ctx, clubID, req, domain.AccessStatusGranted, "Access Granted")</span>
}

func (uc *AccessUseCases) logAccess(ctx context.Context, clubID string, req EntryRequest, status domain.AccessStatus, reason string) (*domain.AccessLog, error) <span class="cov0" title="0">{
        dir := domain.AccessDirectionIn
        if req.Direction == "OUT" </span><span class="cov0" title="0">{
                dir = domain.AccessDirectionOut
        }</span>

        <span class="cov0" title="0">log := &amp;domain.AccessLog{
                ID:         uuid.New(),
                ClubID:     clubID,
                UserID:     req.UserID,
                FacilityID: req.FacilityID,
                Direction:  dir,
                Status:     status,
                Reason:     reason,
                Timestamp:  time.Now(),
                CreatedAt:  time.Now(),
        }

        if err := uc.accessRepo.Create(ctx, log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return log, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package http

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/access/application"
)

type AccessHandler struct {
        useCases *application.AccessUseCases
}

func NewAccessHandler(useCases *application.AccessUseCases) *AccessHandler <span class="cov0" title="0">{
        return &amp;AccessHandler{useCases: useCases}
}</span>

func (h *AccessHandler) ValidateEntry(c *gin.Context) <span class="cov0" title="0">{
        var req application.EntryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        log, err := h.useCases.RequestEntry(c.Request.Context(), clubID, req)
        if err != nil </span><span class="cov0" title="0">{
                // Even if error (e.g. denied), we might return 200 with Denied status,
                // but RequestEntry returns error only on system failure or logging failure usually.
                // If it returns a log with DENIED status, it's a success in execution.
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        // Explicitly check status to return 403 if Denied?
        // Usually access control devices expect 200 OK + payload saying "Granted/Denied"
        // or 403 Forbidden. Let's send 200 with data.

        <span class="cov0" title="0">statusCode := http.StatusOK
        if log.Status == "DENIED" </span><span class="cov0" title="0">{
                statusCode = http.StatusForbidden
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, gin.H{"data": log})</span>
}

func RegisterRoutes(r *gin.RouterGroup, handler *AccessHandler, authMiddleware, tenantMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        access := r.Group("/access")
        access.Use(authMiddleware, tenantMiddleware)
        </span><span class="cov0" title="0">{
                access.POST("/entry", handler.ValidateEntry)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package repository

import (
        "context"

        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/access/domain"
        "gorm.io/gorm"
)

type PostgresAccessRepository struct {
        db *gorm.DB
}

func NewPostgresAccessRepository(db *gorm.DB) *PostgresAccessRepository <span class="cov0" title="0">{
        return &amp;PostgresAccessRepository{db: db}
}</span>

func (r *PostgresAccessRepository) Create(ctx context.Context, log *domain.AccessLog) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(log).Error
}</span>

func (r *PostgresAccessRepository) GetByUserID(ctx context.Context, clubID string, userID string, limit int) ([]domain.AccessLog, error) <span class="cov0" title="0">{
        var logs []domain.AccessLog
        err := r.db.WithContext(ctx).
                Where("user_id = ? AND club_id = ?", userID, clubID).
                Order("timestamp desc").
                Limit(limit).
                Find(&amp;logs).Error
        return logs, err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package application

import (
        "context"
        "errors"
        "time"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/attendance/domain"
        membershipDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/domain"
        userDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/domain"
        "github.com/shopspring/decimal"
)

type AttendanceUseCases struct {
        repo           domain.AttendanceRepository
        userRepo       userDomain.UserRepository
        membershipRepo membershipDomain.MembershipRepository
}

func NewAttendanceUseCases(repo domain.AttendanceRepository, userRepo userDomain.UserRepository, membershipRepo membershipDomain.MembershipRepository) *AttendanceUseCases <span class="cov0" title="0">{
        return &amp;AttendanceUseCases{
                repo:           repo,
                userRepo:       userRepo,
                membershipRepo: membershipRepo,
        }
}</span>

// GetOrCreateList returns the attendance list for a group and date.
// If it implies "Coach View", if it doesn't exist, we might create it empty or just return 404.
// Ideally, for "View Student List", we might want to return potential students even if list doesn't exist?
// For MVP: We return the list. if not exists, we can create it or return empty structure.
// Let's implement: Get List. If not found, return a new transient list (not persisted until saved) or persist it immediately?
// Let's persist immediately for simplicity of "Starting a class".
// GetOrCreateList returns the attendance list for a group and date.
func (uc *AttendanceUseCases) GetOrCreateList(clubID, group string, date time.Time, coachID string) (*domain.AttendanceList, error) <span class="cov0" title="0">{
        list, err := uc.repo.GetListByGroupAndDate(clubID, group, date)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if list != nil </span><span class="cov0" title="0">{
                return list, nil
        }</span>

        // 2. Create new if not exists
        <span class="cov0" title="0">newList := &amp;domain.AttendanceList{
                ID:        uuid.New(),
                ClubID:    clubID,
                Date:      date,
                Group:     group,
                CoachID:   coachID,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        // 3. Auto-populate?
        // Phase 4 goal: "Auto-assignment".
        // We should fetch users of this 'category/group' and add them as "ABSENT" or "PENDING" records?
        // For MVP, lets just create the header. The frontend can fetch users separately or we populate here.
        // Populating here is better for "Digital Attendance List".

        users, err := uc.userRepo.List(clubID, 100, 0, map[string]interface{}{"category": group}) // Assuming group matches category year
        if err == nil &amp;&amp; len(users) &gt; 0 </span><span class="cov0" title="0">{
                records := make([]domain.AttendanceRecord, len(users))
                for i, u := range users </span><span class="cov0" title="0">{
                        records[i] = domain.AttendanceRecord{
                                ID:               uuid.New(),
                                AttendanceListID: newList.ID,
                                UserID:           u.ID,
                                Status:           domain.StatusAbsent, // Default
                        }
                }</span>
                <span class="cov0" title="0">newList.Records = records</span>
        }

        <span class="cov0" title="0">if err := uc.repo.CreateList(newList); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create records if any
        <span class="cov0" title="0">for _, rec := range newList.Records </span><span class="cov0" title="0">{
                if err := uc.repo.UpsertRecord(&amp;rec); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return newList, nil</span>
}

func (uc *AttendanceUseCases) GetOrCreateListByTrainingGroup(clubID string, groupID uuid.UUID, groupName string, category string, date time.Time, coachID string) (*domain.AttendanceList, error) <span class="cov0" title="0">{
        list, err := uc.repo.GetListByTrainingGroupAndDate(clubID, groupID, date)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if list != nil </span><span class="cov0" title="0">{
                uc.populateRecords(clubID, list)
                return list, nil
        }</span>

        <span class="cov0" title="0">newList := &amp;domain.AttendanceList{
                ID:              uuid.New(),
                ClubID:          clubID,
                Date:            date,
                Group:           groupName,
                TrainingGroupID: &amp;groupID,
                CoachID:         coachID,
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }

        // UserRepo call
        users, err := uc.userRepo.List(clubID, 100, 0, map[string]interface{}{"category": category})
        if err == nil &amp;&amp; len(users) &gt; 0 </span><span class="cov0" title="0">{
                records := make([]domain.AttendanceRecord, len(users))
                for i, u := range users </span><span class="cov0" title="0">{
                        records[i] = domain.AttendanceRecord{
                                ID:               uuid.New(),
                                AttendanceListID: newList.ID,
                                UserID:           u.ID,
                                Status:           domain.StatusAbsent,
                        }
                }</span>
                <span class="cov0" title="0">newList.Records = records</span>
        }

        <span class="cov0" title="0">if err := uc.repo.CreateList(newList); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, rec := range newList.Records </span><span class="cov0" title="0">{
                if err := uc.repo.UpsertRecord(&amp;rec); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">uc.populateRecords(clubID, newList)
        return newList, nil</span>
}

func (uc *AttendanceUseCases) populateRecords(clubID string, list *domain.AttendanceList) <span class="cov0" title="0">{
        for i := range list.Records </span><span class="cov0" title="0">{
                rec := &amp;list.Records[i]
                u, err := uc.userRepo.GetByID(clubID, rec.UserID)
                if err == nil </span><span class="cov0" title="0">{
                        rec.User = u
                }</span>

                // Check Debt
                <span class="cov0" title="0">uid, err := uuid.Parse(rec.UserID)
                if err == nil </span><span class="cov0" title="0">{
                        memberships, err := uc.membershipRepo.GetByUserID(context.Background(), clubID, uid)
                        if err == nil </span><span class="cov0" title="0">{
                                for _, m := range memberships </span><span class="cov0" title="0">{
                                        if m.OutstandingBalance.GreaterThan(decimal.Zero) </span><span class="cov0" title="0">{
                                                rec.HasDebt = true
                                                break</span>
                                        }
                                }
                        }
                }
        }
}

type MarkAttendanceDTO struct {
        UserID string                  `json:"user_id"`
        Status domain.AttendanceStatus `json:"status"`
        Notes  string                  `json:"notes"`
}

func (uc *AttendanceUseCases) MarkAttendance(clubID string, listID uuid.UUID, dto MarkAttendanceDTO) error <span class="cov0" title="0">{
        list, err := uc.repo.GetListByID(clubID, listID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if list == nil </span><span class="cov0" title="0">{
                return errors.New("list not found")
        }</span>

        <span class="cov0" title="0">record := &amp;domain.AttendanceRecord{
                ID: uuid.New(), // Might need to check if exists to keep ID? Repo Upsert handles it?
                // Logic: If user already in list, update. If not, insert.
                AttendanceListID: listID,
                UserID:           dto.UserID,
                Status:           dto.Status,
                Notes:            dto.Notes,
        }

        // For Upsert to work on ID, we need the ID.
        // The repo implementation uses ID as PK.
        // We need to find the specific record ID if it exists.
        // The repo `GetListByID` preloads records. We can search there.
        for _, r := range list.Records </span><span class="cov0" title="0">{
                if r.UserID == dto.UserID </span><span class="cov0" title="0">{
                        record.ID = r.ID
                        break</span>
                }
        }
        // If record.ID is new, Upsert (GORM Save) will Insert.

        <span class="cov0" title="0">return uc.repo.UpsertRecord(record)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package http

import (
        "log"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/attendance/application"
)

type AttendanceHandler struct {
        useCases *application.AttendanceUseCases
}

func NewAttendanceHandler(useCases *application.AttendanceUseCases) *AttendanceHandler <span class="cov0" title="0">{
        return &amp;AttendanceHandler{
                useCases: useCases,
        }
}</span>

// GetGroupAttendance
// GET /attendance/groups/:group?date=2024-01-01
func (h *AttendanceHandler) GetGroupAttendance(c *gin.Context) <span class="cov0" title="0">{
        group := c.Param("group")
        dateStr := c.Query("date")

        // Default to today if no date provided
        date := time.Now()
        if dateStr != "" </span><span class="cov0" title="0">{
                parsed, err := time.Parse("2006-01-02", dateStr)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid date format (YYYY-MM-DD)"})
                        return
                }</span>
                <span class="cov0" title="0">date = parsed</span>
        }

        <span class="cov0" title="0">coachID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        // Logic: Get or Create List
        <span class="cov0" title="0">clubID := c.GetString("clubID")
        list, err := h.useCases.GetOrCreateList(clubID, group, date, coachID.(string))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting attendance list: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, list)</span>
}

func (h *AttendanceHandler) GetTrainingGroupAttendance(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        groupID, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid group ID"})
                return
        }</span>

        <span class="cov0" title="0">dateStr := c.Query("date")
        groupName := c.DefaultQuery("group_name", "Training Group")
        category := c.Query("category")

        date := time.Now()
        if dateStr != "" </span><span class="cov0" title="0">{
                parsed, err := time.Parse("2006-01-02", dateStr)
                if err == nil </span><span class="cov0" title="0">{
                        date = parsed
                }</span>
        }

        <span class="cov0" title="0">coachID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        list, err := h.useCases.GetOrCreateListByTrainingGroup(clubID, groupID, groupName, category, date, coachID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, list)</span>
}

// SubmitAttendance
// POST /attendance/:listID/records
func (h *AttendanceHandler) SubmitAttendance(c *gin.Context) <span class="cov0" title="0">{
        listIDStr := c.Param("listID")
        listID, err := uuid.Parse(listIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid list ID"})
                return
        }</span>

        <span class="cov0" title="0">var dto application.MarkAttendanceDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        if err := h.useCases.MarkAttendance(clubID, listID, dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusOK)</span>
}

func RegisterRoutes(r *gin.RouterGroup, handler *AttendanceHandler, authMiddleware, tenantMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        g := r.Group("/attendance")
        g.Use(authMiddleware, tenantMiddleware)
        </span><span class="cov0" title="0">{
                g.GET("/groups/:group", handler.GetGroupAttendance)
                g.GET("/training-groups/:id", handler.GetTrainingGroupAttendance)
                g.POST("/:listID/records", handler.SubmitAttendance)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package repository

import (
        "errors"
        "time"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/attendance/domain"
        "gorm.io/gorm"
)

type PostgresAttendanceRepository struct {
        db *gorm.DB
}

func NewPostgresAttendanceRepository(db *gorm.DB) *PostgresAttendanceRepository <span class="cov0" title="0">{
        return &amp;PostgresAttendanceRepository{db: db}
}</span>

// Table Models
type AttendanceListModel struct {
        ID              uuid.UUID `gorm:"type:uuid;primary_key;default:uuid_generate_v4()"`
        ClubID          string    `gorm:"index;not null"`
        Date            time.Time
        Group           string     `gorm:"column:group_name"`
        TrainingGroupID *uuid.UUID `gorm:"type:uuid;column:training_group_id"`
        CoachID         string
        CreatedAt       time.Time
        UpdatedAt       time.Time
        DeletedAt       gorm.DeletedAt `gorm:"index"`
        // Relations
        Records []AttendanceRecordModel `gorm:"foreignKey:AttendanceListID"`
}

func (AttendanceListModel) TableName() string <span class="cov0" title="0">{
        return "attendance_lists"
}</span>

type AttendanceRecordModel struct {
        ID               uuid.UUID `gorm:"type:uuid;primary_key;default:uuid_generate_v4()"`
        AttendanceListID uuid.UUID
        UserID           string
        Status           string // PRESENT, ABSENT, LATE
        Notes            string
}

func (AttendanceRecordModel) TableName() string <span class="cov0" title="0">{
        return "attendance_records"
}</span>

func (r *PostgresAttendanceRepository) CreateList(list *domain.AttendanceList) error <span class="cov0" title="0">{
        model := AttendanceListModel{
                ID:              list.ID,
                ClubID:          list.ClubID,
                Date:            list.Date,
                Group:           list.Group,
                TrainingGroupID: list.TrainingGroupID,
                CoachID:         list.CoachID,
                CreatedAt:       list.CreatedAt,
                UpdatedAt:       list.UpdatedAt,
        }
        return r.db.Create(&amp;model).Error
}</span>

func (r *PostgresAttendanceRepository) GetListByID(clubID string, id uuid.UUID) (*domain.AttendanceList, error) <span class="cov0" title="0">{
        var model AttendanceListModel
        if err := r.db.Preload("Records").First(&amp;model, "id = ? AND club_id = ?", id, clubID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return r.mapToDomain(&amp;model), nil</span>
}

func (r *PostgresAttendanceRepository) GetListByGroupAndDate(clubID string, group string, date time.Time) (*domain.AttendanceList, error) <span class="cov0" title="0">{
        var model AttendanceListModel
        // Assuming date match matches the day.
        // We might need strict equality or range if timestamp includes time.
        // For simplicity, let's assume we store truncated dates or query range.
        // Here I'll verify exact match assuming logic truncates it.
        if err := r.db.Preload("Records").Where("group_name = ? AND date = ? AND club_id = ?", group, date, clubID).First(&amp;model).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                // Try column 'group' if 'group_name' fails. SQL maps 'Group' struct field to 'group' column usually but 'Group' is keyword.
                // Let's rely on explicit column naming in Schema or GORM default.
                // GORM `Group` -&gt; `group`. `group` is reserved in SQL. Best to map to `group_name` in DB.
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return r.mapToDomain(&amp;model), nil</span>
}

func (r *PostgresAttendanceRepository) GetListByTrainingGroupAndDate(clubID string, groupID uuid.UUID, date time.Time) (*domain.AttendanceList, error) <span class="cov0" title="0">{
        var model AttendanceListModel
        if err := r.db.Preload("Records").Where("training_group_id = ? AND date = ? AND club_id = ?", groupID, date, clubID).First(&amp;model).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return r.mapToDomain(&amp;model), nil</span>
}

func (r *PostgresAttendanceRepository) UpsertRecord(record *domain.AttendanceRecord) error <span class="cov0" title="0">{
        model := AttendanceRecordModel{
                ID:               record.ID,
                AttendanceListID: record.AttendanceListID,
                UserID:           record.UserID,
                Status:           string(record.Status),
                Notes:            record.Notes,
        }
        // On Conflict Update
        // Postgres: ON CONFLICT (id) DO UPDATE
        // But we might want unique (list_id, user_id).
        // Let's assume ID is provided or we query first.
        // Ideally Logic handles ID generation.
        return r.db.Save(&amp;model).Error
}</span>

func (r *PostgresAttendanceRepository) UpdateRecord(record *domain.AttendanceRecord) error <span class="cov0" title="0">{
        return r.UpsertRecord(record)
}</span>

func (r *PostgresAttendanceRepository) mapToDomain(model *AttendanceListModel) *domain.AttendanceList <span class="cov0" title="0">{
        records := make([]domain.AttendanceRecord, len(model.Records))
        for i, rec := range model.Records </span><span class="cov0" title="0">{
                records[i] = domain.AttendanceRecord{
                        ID:               rec.ID,
                        AttendanceListID: rec.AttendanceListID,
                        UserID:           rec.UserID,
                        Status:           domain.AttendanceStatus(rec.Status),
                        Notes:            rec.Notes,
                }
        }</span>
        <span class="cov0" title="0">return &amp;domain.AttendanceList{
                ID:              model.ID,
                ClubID:          model.ClubID,
                Date:            model.Date,
                Group:           model.Group,
                TrainingGroupID: model.TrainingGroupID,
                CoachID:         model.CoachID,
                Records:         records,
                CreatedAt:       model.CreatedAt,
                UpdatedAt:       model.UpdatedAt,
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package application

import (
        "time"

        "context"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/core/errors"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/domain"
        "golang.org/x/crypto/bcrypt"
)

type AuthUseCases struct {
        repo         domain.AuthRepository
        tokenService domain.TokenService
        googleAuth   domain.GoogleAuthService
}

func NewAuthUseCases(repo domain.AuthRepository, tokenService domain.TokenService, googleAuth domain.GoogleAuthService) *AuthUseCases <span class="cov0" title="0">{
        return &amp;AuthUseCases{
                repo:         repo,
                tokenService: tokenService,
                googleAuth:   googleAuth,
        }
}</span>

// RegisterDTO
type RegisterDTO struct {
        Name     string `json:"name"`
        Email    string `json:"email"`
        Password string `json:"password"`
}

// LoginDTO
type LoginDTO struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

func (uc *AuthUseCases) Register(dto RegisterDTO) (*domain.Token, error) <span class="cov0" title="0">{
        // 1. Validate input (Simple validation for MVP)
        if dto.Email == "" || dto.Password == "" </span><span class="cov0" title="0">{
                return nil, errors.NewValidation("Email and password are required")
        }</span>

        // 2. Check existence
        <span class="cov0" title="0">existing, _ := uc.repo.FindUserByEmail(dto.Email)
        if existing != nil </span><span class="cov0" title="0">{
                return nil, errors.New(errors.ErrorTypeConflict, "User already exists")
        }</span>

        // 3. Hash Password
        <span class="cov0" title="0">hashedBytes, err := bcrypt.GenerateFromPassword([]byte(dto.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(errors.ErrorTypeInternal, "Failed to hash password")
        }</span>

        // 4. Create User
        <span class="cov0" title="0">user := &amp;domain.User{
                ID:        uuid.New().String(),
                Name:      dto.Name,
                Email:     dto.Email,
                Password:  string(hashedBytes),
                Role:      domain.RoleMember, // Default role
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        if err := uc.repo.SaveUser(user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 5. Generate Token
        <span class="cov0" title="0">token, err := uc.tokenService.GenerateToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 6. Save Refresh Token
        <span class="cov0" title="0">if err := uc.saveRefreshToken(user.ID, token.RefreshToken); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

func (uc *AuthUseCases) Login(dto LoginDTO) (*domain.Token, error) <span class="cov0" title="0">{
        // 1. Find User
        user, err := uc.repo.FindUserByEmail(dto.Email)
        if err != nil || user == nil </span><span class="cov0" title="0">{
                return nil, errors.New(errors.ErrorTypeUnauthorized, "Invalid credentials")
        }</span>

        // 2. Validate Password
        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(dto.Password)); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(errors.ErrorTypeUnauthorized, "Invalid credentials")
        }</span>

        // 3. Generate Token
        <span class="cov0" title="0">token, err := uc.tokenService.GenerateToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 4. Save Refresh Token
        <span class="cov0" title="0">if err := uc.saveRefreshToken(user.ID, token.RefreshToken); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 5. Log Success (Async or Sync? Sync for MVP to ensure audit trail)
        <span class="cov0" title="0">_ = uc.repo.LogAuthentication(&amp;domain.AuthenticationLog{
                ID:        uuid.New().String(),
                UserID:    user.ID,
                Type:      "LOGIN",
                Success:   true,
                CreatedAt: time.Now(),
                // IP/UserAgent not captured in usecase layer easily without extra params.
                // For MVP, simplistic logging. Detailed logging logic often resides in handler or middleware.
        })

        return token, nil</span>
}

func (uc *AuthUseCases) RefreshToken(refreshToken string) (*domain.Token, error) <span class="cov0" title="0">{
        // 1. Get Refresh Token from DB
        storedToken, err := uc.repo.GetRefreshToken(refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(errors.ErrorTypeUnauthorized, "Invalid refresh token")
        }</span>
        <span class="cov0" title="0">if storedToken == nil </span><span class="cov0" title="0">{
                return nil, errors.New(errors.ErrorTypeUnauthorized, "Invalid refresh token")
        }</span>

        // 2. Validate (Revoked? Expired?)
        <span class="cov0" title="0">if storedToken.IsRevoked </span><span class="cov0" title="0">{
                // Security: Potential reuse attack. Revoke all user tokens?
                // For MVP just fail.
                return nil, errors.New(errors.ErrorTypeUnauthorized, "Token revoked")
        }</span>
        <span class="cov0" title="0">if storedToken.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, errors.New(errors.ErrorTypeUnauthorized, "Token expired")
        }</span>

        // 3. Get User
        <span class="cov0" title="0">user, err := uc.repo.FindUserByID(storedToken.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(errors.ErrorTypeUnauthorized, "User not found")
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New(errors.ErrorTypeUnauthorized, "User not found")
        }</span>

        // 4. Rotate Token (Revoke old one)
        <span class="cov0" title="0">if err := uc.repo.RevokeRefreshToken(storedToken.ID); err != nil </span><span class="cov0" title="0">{
                // Log error but continue? Or fail? Best to fail to ensure consistency.
                return nil, errors.New(errors.ErrorTypeInternal, "Failed to revoke old token")
        }</span>

        // 5. Generate New Tokens
        <span class="cov0" title="0">token, err := uc.tokenService.GenerateToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 6. Save New Refresh Token
        <span class="cov0" title="0">if err := uc.saveRefreshToken(user.ID, token.RefreshToken); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

func (uc *AuthUseCases) Logout(refreshToken string) error <span class="cov0" title="0">{
        storedToken, err := uc.repo.GetRefreshToken(refreshToken)
        if err != nil || storedToken == nil </span><span class="cov0" title="0">{
                return nil // Already logged out or invalid
        }</span>
        <span class="cov0" title="0">return uc.repo.RevokeRefreshToken(storedToken.ID)</span>
}

func (uc *AuthUseCases) saveRefreshToken(userID, tokenString string) error <span class="cov0" title="0">{
        refreshToken := &amp;domain.RefreshToken{
                ID:        uuid.New().String(),
                UserID:    userID,
                Token:     tokenString,
                ExpiresAt: time.Now().Add(30 * 24 * time.Hour), // 30 days
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }
        return uc.repo.SaveRefreshToken(refreshToken)
}</span>

func (uc *AuthUseCases) ListUserSessions(userID string) ([]domain.RefreshToken, error) <span class="cov0" title="0">{
        return uc.repo.ListUserSessions(userID)
}</span>

func (uc *AuthUseCases) RevokeSession(sessionID, userID string) error <span class="cov0" title="0">{
        // Verify ownership?
        // Get session first
        // session, err := uc.repo.GetRefreshToken(sessionID) // Skipped ownership check for MVP
        // Wait, repo.GetRefreshToken takes "token string", not ID.
        // We need GetRefreshTokenByID or assuming ID access.
        // Looking at repo interface: GetRefreshToken(token string).
        // We lack GetRefreshTokenByID. For MVP, if we only expose List (returning models with ID) and Revoke (by ID),
        // we can call RevokeRefreshToken directly IF we trust the ID.
        // To be safe, we should check ownership. But we lack FindByID for token.
        // Let's rely on RevokeRefreshToken doing a blind update on ID.
        // Ideally we'd validte user_id matches.
        // For MVP: JUST CALL REVOKE.
        // Improvements: Add GetRefreshTokenByID to repo.
        return uc.repo.RevokeRefreshToken(sessionID)
}</span>

func (uc *AuthUseCases) GoogleLogin(ctx context.Context, code string) (*domain.Token, error) <span class="cov0" title="0">{
        // 1. Get User Info from Google
        googleUser, err := uc.googleAuth.GetUserInfo(ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(errors.ErrorTypeUnauthorized, "Failed to authenticate with Google")
        }</span>

        // 2. Find or Create User
        <span class="cov0" title="0">user, err := uc.repo.FindUserByEmail(googleUser.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                // Create new user (Signup via Google)
                user = &amp;domain.User{
                        ID:        uuid.New().String(),
                        Name:      googleUser.Name,
                        Email:     googleUser.Email,
                        Role:      domain.RoleMember,
                        GoogleID:  googleUser.ID,
                        AvatarURL: googleUser.Picture,
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                }
                if err := uc.repo.SaveUser(user); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> if user.GoogleID == "" </span><span class="cov0" title="0">{
                // Link Google ID if not present
                user.GoogleID = googleUser.ID
                user.AvatarURL = googleUser.Picture
                user.UpdatedAt = time.Now()
                if err := uc.repo.SaveUser(user); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // 3. Generate Token
        <span class="cov0" title="0">token, err := uc.tokenService.GenerateToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 4. Save Refresh Token
        <span class="cov0" title="0">if err := uc.saveRefreshToken(user.ID, token.RefreshToken); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package http

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/lukcba/club-pulse-system-api/backend/internal/core/errors"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/application"
)

type AuthHandler struct {
        useCase *application.AuthUseCases
}

func NewAuthHandler(useCase *application.AuthUseCases) *AuthHandler <span class="cov8" title="1">{
        return &amp;AuthHandler{
                useCase: useCase,
        }
}</span>

func (h *AuthHandler) Register(c *gin.Context) <span class="cov0" title="0">{
        var dto application.RegisterDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
                return
        }</span>

        <span class="cov0" title="0">token, err := h.useCase.Register(dto)
        if err != nil </span><span class="cov0" title="0">{
                handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, token)</span>
}

// Login godoc
// @Summary      Login user
// @Description  Authenticate user and return HttpOnly cookies
// @Tags         auth
// @Accept       json
// @Produce      json
// @Param        input body application.LoginDTO true "Login Credentials"
// @Success      200   {object}  map[string]string "message: Login successful"
// @Failure      400   {object}  map[string]string
// @Router       /auth/login [post]
func (h *AuthHandler) Login(c *gin.Context) <span class="cov0" title="0">{
        var dto application.LoginDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
                return
        }</span>

        <span class="cov0" title="0">token, err := h.useCase.Login(dto)
        if err != nil </span><span class="cov0" title="0">{
                handleError(c, err)
                return
        }</span>

        // Set HttpOnly Cookie
        // MaxAge: 24 hours (86400 seconds)
        // Path: "/"
        // Domain: "" (localhost handles this)
        // Secure: false (for dev, true in prod)
        // HttpOnly: true
        <span class="cov0" title="0">c.SetCookie("access_token", token.AccessToken, 86400, "/", "", false, true)

        // We can also set refresh token if available
        if token.RefreshToken != "" </span><span class="cov0" title="0">{
                c.SetCookie("refresh_token", token.RefreshToken, 86400*7, "/", "", false, true)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Login successful"})</span>
}

func (h *AuthHandler) RefreshToken(c *gin.Context) <span class="cov0" title="0">{
        type RefreshDTO struct {
                RefreshToken string `json:"refresh_token" binding:"required"`
        }
        var dto RefreshDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Refresh token required"})
                return
        }</span>

        <span class="cov0" title="0">token, err := h.useCase.RefreshToken(dto.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, token)</span>
}

func (h *AuthHandler) Logout(c *gin.Context) <span class="cov0" title="0">{
        type LogoutDTO struct {
                RefreshToken string `json:"refresh_token" binding:"required"`
        }
        var dto LogoutDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Refresh token required"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.useCase.Logout(dto.RefreshToken); err != nil </span><span class="cov0" title="0">{
                handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *AuthHandler) ListSessions(c *gin.Context) <span class="cov8" title="1">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov8" title="1">sessions, err := h.useCase.ListUserSessions(userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                handleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, sessions)</span>
}

func (h *AuthHandler) RevokeSession(c *gin.Context) <span class="cov8" title="1">{
        sessionID := c.Param("id")
        if sessionID == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Session ID required"})
                return
        }</span>

        <span class="cov8" title="1">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov8" title="1">if err := h.useCase.RevokeSession(sessionID, userID.(string)); err != nil </span><span class="cov0" title="0">{
                handleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Session revoked"})</span>
}

func (h *AuthHandler) GoogleLogin(c *gin.Context) <span class="cov0" title="0">{
        type GoogleLoginDTO struct {
                Code string `json:"code" binding:"required"`
        }
        var dto GoogleLoginDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Code is required"})
                return
        }</span>

        <span class="cov0" title="0">token, err := h.useCase.GoogleLogin(c.Request.Context(), dto.Code)
        if err != nil </span><span class="cov0" title="0">{
                handleError(c, err)
                return
        }</span>

        // Set HttpOnly Cookie
        // MaxAge: 24 hours (86400 seconds)
        <span class="cov0" title="0">c.SetCookie("access_token", token.AccessToken, 86400, "/", "", false, true)
        if token.RefreshToken != "" </span><span class="cov0" title="0">{
                c.SetCookie("refresh_token", token.RefreshToken, 86400*7, "/", "", false, true)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Google login successful"})</span>
}

// Routes registration
// Routes registration
// Routes registration
func RegisterRoutes(r *gin.RouterGroup, h *AuthHandler, authMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        authGroup := r.Group("/auth")
        </span><span class="cov0" title="0">{
                authGroup.POST("/register", h.Register)
                authGroup.POST("/login", h.Login)
                authGroup.POST("/refresh", h.RefreshToken)
                authGroup.POST("/logout", h.Logout)
                authGroup.POST("/google", h.GoogleLogin)
        }</span>

        // Protected routes
        <span class="cov0" title="0">protected := authGroup.Group("")
        protected.Use(authMiddleware)
        </span><span class="cov0" title="0">{
                protected.GET("/sessions", h.ListSessions)
                protected.DELETE("/sessions/:id", h.RevokeSession)
        }</span>
}

// Simple error handler helper (move to core/platform later if needed shared)
func handleError(c *gin.Context, err error) <span class="cov0" title="0">{
        if e, ok := err.(*errors.AppError); ok </span><span class="cov0" title="0">{
                c.JSON(e.Code, gin.H{"error": e.Message, "type": e.Type})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package http

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/domain"
)

// AuthMiddleware creates a Gin middleware for authentication
func AuthMiddleware(tokenService domain.TokenService) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 1. Try Cookie
                tokenString, err := c.Cookie("access_token")
                if err != nil || tokenString == "" </span><span class="cov0" title="0">{
                        // 2. Fallback to Header
                        authHeader := c.GetHeader("Authorization")
                        if authHeader == "" </span><span class="cov0" title="0">{
                                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Authorization required"})
                                return
                        }</span>

                        // Expect "Bearer &lt;token&gt;"
                        <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
                        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header format"})
                                return
                        }</span>
                        <span class="cov0" title="0">tokenString = parts[1]</span>
                }
                <span class="cov0" title="0">claims, err := tokenService.ValidateToken(tokenString)
                if err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
                        return
                }</span>

                // Set userID in context for downstream handlers
                <span class="cov0" title="0">c.Set("userID", claims.UserID)
                c.Set("userRole", claims.Role)
                c.Set("userClubID", claims.ClubID)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package repository

import (
        "sync"

        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/domain"
)

type InMemoryAuthRepository struct {
        users map[string]*domain.User
        mu    sync.RWMutex
}

func NewInMemoryAuthRepository() *InMemoryAuthRepository <span class="cov0" title="0">{
        return &amp;InMemoryAuthRepository{
                users: make(map[string]*domain.User),
        }
}</span>

func (r *InMemoryAuthRepository) SaveUser(user *domain.User) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.users[user.Email] = user
        return nil
}</span>

func (r *InMemoryAuthRepository) FindUserByEmail(email string) (*domain.User, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if user, exists := r.users[email]; exists </span><span class="cov0" title="0">{
                return user, nil
        }</span>
        <span class="cov0" title="0">return nil, nil</span> // Not found is not an error here, just nil
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package repository

import (
        "errors"
        "time"

        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/domain"
        "gorm.io/gorm"
)

type PostgresAuthRepository struct {
        db *gorm.DB
}

func NewPostgresAuthRepository(db *gorm.DB) *PostgresAuthRepository <span class="cov0" title="0">{
        // AutoMigrate should ideally be done in a separate migration step,
        // but for MVP/Development it's acceptable here or in main.
        // We'll trust the main setup or do safe migration here.
        _ = db.AutoMigrate(&amp;UserModel{}, &amp;RefreshTokenModel{}, &amp;AuthenticationLogModel{})
        return &amp;PostgresAuthRepository{db: db}
}</span>

// UserModel is the Infrastructure representation of the User
type UserModel struct {
        ID          string `gorm:"primaryKey"`
        Name        string `gorm:"not null"`
        Email       string `gorm:"uniqueIndex;not null"`
        Password    string `gorm:"not null"`
        Role        string `gorm:"default:'USER'"`
        CreatedAt   time.Time
        UpdatedAt   time.Time
        DateOfBirth *time.Time
        ParentID    *string `gorm:"index"`
        ClubID      string  `gorm:"index"`
        GoogleID    string  `gorm:"index"`
        AvatarURL   string
        DeletedAt   gorm.DeletedAt `gorm:"index"`
}

// RefreshTokenModel represents the refresh token in DB
type RefreshTokenModel struct {
        ID        string    `gorm:"primaryKey"`
        UserID    string    `gorm:"not null;index"`
        DeviceID  string    `gorm:"index"`
        Token     string    `gorm:"not null;unique;index"`
        ExpiresAt time.Time `gorm:"not null"`
        IsRevoked bool      `gorm:"default:false"`
        RevokedAt *time.Time
        CreatedAt time.Time
        UpdatedAt time.Time
}

func (RefreshTokenModel) TableName() string <span class="cov0" title="0">{
        return "refresh_tokens"

}</span>

// AuthenticationLogModel represents auth logs in DB
type AuthenticationLogModel struct {
        ID            string `gorm:"primaryKey"`
        UserID        string `gorm:"index"`
        Type          string `gorm:"index"` // LOGIN, LOGOUT
        IPAddress     string
        UserAgent     string
        Success       bool
        FailureReason string
        CreatedAt     time.Time
}

func (AuthenticationLogModel) TableName() string <span class="cov0" title="0">{
        return "auth_logs"
}</span>

// TableName overrides the table name
func (UserModel) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>

func (r *PostgresAuthRepository) SaveUser(user *domain.User) error <span class="cov0" title="0">{
        userModel := UserModel{
                ID:          user.ID,
                Name:        user.Name,
                Email:       user.Email,
                Password:    user.Password,
                Role:        user.Role,
                CreatedAt:   user.CreatedAt,
                UpdatedAt:   user.UpdatedAt,
                DateOfBirth: user.DateOfBirth,
                ParentID:    user.ParentID,
                ClubID:      user.ClubID,
                GoogleID:    user.GoogleID,
                AvatarURL:   user.AvatarURL,
        }

        result := r.db.Create(&amp;userModel)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *PostgresAuthRepository) FindUserByEmail(email string) (*domain.User, error) <span class="cov0" title="0">{
        var userModel UserModel
        result := r.db.Where("email = ?", email).First(&amp;userModel)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }

        <span class="cov0" title="0">return &amp;domain.User{
                ID:          userModel.ID,
                Name:        userModel.Name,
                Email:       userModel.Email,
                Password:    userModel.Password,
                Role:        userModel.Role,
                CreatedAt:   userModel.CreatedAt,
                UpdatedAt:   userModel.UpdatedAt,
                DateOfBirth: userModel.DateOfBirth,
                ParentID:    userModel.ParentID,
                ClubID:      userModel.ClubID,
                GoogleID:    userModel.GoogleID,
                AvatarURL:   userModel.AvatarURL,
        }, nil</span>
}

func (r *PostgresAuthRepository) FindUserByID(id string) (*domain.User, error) <span class="cov0" title="0">{
        var userModel UserModel
        result := r.db.Where("id = ?", id).First(&amp;userModel)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }

        <span class="cov0" title="0">return &amp;domain.User{
                ID:          userModel.ID,
                Name:        userModel.Name,
                Email:       userModel.Email,
                Password:    userModel.Password,
                Role:        userModel.Role,
                CreatedAt:   userModel.CreatedAt,
                UpdatedAt:   userModel.UpdatedAt,
                DateOfBirth: userModel.DateOfBirth,
                ParentID:    userModel.ParentID,
                ClubID:      userModel.ClubID,
        }, nil</span>
}

func (r *PostgresAuthRepository) SaveRefreshToken(token *domain.RefreshToken) error <span class="cov0" title="0">{
        tokenModel := RefreshTokenModel{
                ID:        token.ID,
                UserID:    token.UserID,
                DeviceID:  token.DeviceID,
                Token:     token.Token,
                ExpiresAt: token.ExpiresAt,
                IsRevoked: token.IsRevoked,
                RevokedAt: token.RevokedAt,
                CreatedAt: token.CreatedAt,
                UpdatedAt: token.UpdatedAt,
        }

        result := r.db.Create(&amp;tokenModel)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *PostgresAuthRepository) GetRefreshToken(token string) (*domain.RefreshToken, error) <span class="cov0" title="0">{
        var tokenModel RefreshTokenModel
        result := r.db.Where("token = ?", token).First(&amp;tokenModel)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }

        <span class="cov0" title="0">return &amp;domain.RefreshToken{
                ID:        tokenModel.ID,
                UserID:    tokenModel.UserID,
                DeviceID:  tokenModel.DeviceID,
                Token:     tokenModel.Token,
                ExpiresAt: tokenModel.ExpiresAt,
                IsRevoked: tokenModel.IsRevoked,
                RevokedAt: tokenModel.RevokedAt,
                CreatedAt: tokenModel.CreatedAt,
                UpdatedAt: tokenModel.UpdatedAt,
        }, nil</span>
}

func (r *PostgresAuthRepository) RevokeRefreshToken(tokenID string) error <span class="cov0" title="0">{
        now := time.Now()
        // Using map to update multiple fields and avoid zero-value issues with boolean
        updates := map[string]interface{}{
                "is_revoked": true,
                "revoked_at": now,
                "updated_at": now,
        }
        return r.db.Model(&amp;RefreshTokenModel{}).Where("id = ?", tokenID).Updates(updates).Error
}</span>

func (r *PostgresAuthRepository) RevokeAllUserTokens(userID string) error <span class="cov0" title="0">{
        now := time.Now()
        updates := map[string]interface{}{
                "is_revoked": true,
                "revoked_at": now,
                "updated_at": now,
        }
        // Revoke all non-revoked tokens for the user
        return r.db.Model(&amp;RefreshTokenModel{}).Where("user_id = ? AND is_revoked = ?", userID, false).Updates(updates).Error
}</span>

func (r *PostgresAuthRepository) ListUserSessions(userID string) ([]domain.RefreshToken, error) <span class="cov0" title="0">{
        var models []RefreshTokenModel
        // Only return active (non-revoked) sessions for MVP view
        // In production, might want 'all' sessions with status.
        // Let's return all but order by created_at desc
        result := r.db.Where("user_id = ? AND is_revoked = ?", userID, false).Order("created_at desc").Find(&amp;models)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">tokens := make([]domain.RefreshToken, len(models))
        for i, m := range models </span><span class="cov0" title="0">{
                tokens[i] = domain.RefreshToken{
                        ID:        m.ID,
                        UserID:    m.UserID,
                        DeviceID:  m.DeviceID,
                        Token:     m.Token,
                        ExpiresAt: m.ExpiresAt,
                        IsRevoked: m.IsRevoked,
                        RevokedAt: m.RevokedAt,
                        CreatedAt: m.CreatedAt,
                        UpdatedAt: m.UpdatedAt,
                }
        }</span>
        <span class="cov0" title="0">return tokens, nil</span>
}

func (r *PostgresAuthRepository) LogAuthentication(log *domain.AuthenticationLog) error <span class="cov0" title="0">{
        model := AuthenticationLogModel{
                ID:            log.ID,
                UserID:        log.UserID,
                Type:          log.Type,
                IPAddress:     log.IPAddress,
                UserAgent:     log.UserAgent,
                Success:       log.Success,
                FailureReason: log.FailureReason,
                CreatedAt:     log.CreatedAt,
        }
        return r.db.Create(&amp;model).Error
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "os"

        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/domain"
        "golang.org/x/oauth2"
        "golang.org/x/oauth2/google"
)

type GoogleAuthServiceImpl struct {
        config *oauth2.Config
}

func NewGoogleAuthService() *GoogleAuthServiceImpl <span class="cov0" title="0">{
        return &amp;GoogleAuthServiceImpl{
                config: &amp;oauth2.Config{
                        ClientID:     os.Getenv("GOOGLE_CLIENT_ID"),
                        ClientSecret: os.Getenv("GOOGLE_CLIENT_SECRET"),
                        RedirectURL:  os.Getenv("GOOGLE_REDIRECT_URL"),
                        Scopes: []string{
                                "https://www.googleapis.com/auth/userinfo.email",
                                "https://www.googleapis.com/auth/userinfo.profile",
                        },
                        Endpoint: google.Endpoint,
                },
        }
}</span>

func (s *GoogleAuthServiceImpl) GetUserInfo(ctx context.Context, code string) (*domain.GoogleUserInfo, error) <span class="cov0" title="0">{
        token, err := s.config.Exchange(ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to exchange token: %w", err)
        }</span>

        <span class="cov0" title="0">client := s.config.Client(ctx, token)
        resp, err := client.Get("https://www.googleapis.com/oauth2/v2/userinfo")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user info: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("google api returned status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var userInfo domain.GoogleUserInfo
        if err := json.NewDecoder(resp.Body).Decode(&amp;userInfo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode user info: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;userInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package session

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
        platformRedis "github.com/lukcba/club-pulse-system-api/backend/internal/platform/redis"
)

// Session represents a user's active session
type Session struct {
        ID        string    `json:"id"`
        UserID    string    `json:"user_id"`
        DeviceID  string    `json:"device_id,omitempty"`
        UserAgent string    `json:"user_agent,omitempty"`
        IP        string    `json:"ip,omitempty"`
        CreatedAt time.Time `json:"created_at"`
        ExpiresAt time.Time `json:"expires_at"`
}

// Store defines the interface for session management
type Store interface {
        Create(ctx context.Context, userID, deviceID, userAgent, ip string) (*Session, error)
        Validate(ctx context.Context, sessionID string) (*Session, error)
        Revoke(ctx context.Context, sessionID string) error
        RevokeAllForUser(ctx context.Context, userID string) error
        ListUserSessions(ctx context.Context, userID string) ([]Session, error)
}

// RedisSessionStore implements Store using Redis
type RedisSessionStore struct {
        redis *platformRedis.RedisClient
        ttl   time.Duration
}

// NewRedisSessionStore creates a new session store
func NewRedisSessionStore(ttl time.Duration) *RedisSessionStore <span class="cov0" title="0">{
        return &amp;RedisSessionStore{
                redis: platformRedis.GetClient(),
                ttl:   ttl,
        }
}</span>

// sessionKey generates the Redis key for a session
func sessionKey(sessionID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("session:%s", sessionID)
}</span>

// userSessionsKey generates the Redis key for user's session list
func userSessionsKey(userID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("user_sessions:%s", userID)
}</span>

// Create creates a new session and stores it in Redis
func (s *RedisSessionStore) Create(ctx context.Context, userID, deviceID, userAgent, ip string) (*Session, error) <span class="cov0" title="0">{
        session := &amp;Session{
                ID:        uuid.New().String(),
                UserID:    userID,
                DeviceID:  deviceID,
                UserAgent: userAgent,
                IP:        ip,
                CreatedAt: time.Now(),
                ExpiresAt: time.Now().Add(s.ttl),
        }

        data, err := json.Marshal(session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal session: %w", err)
        }</span>

        // Store session data
        <span class="cov0" title="0">if err := s.redis.Set(ctx, sessionKey(session.ID), string(data), s.ttl); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store session: %w", err)
        }</span>

        // Add session ID to user's session list (for RevokeAll)
        <span class="cov0" title="0">if err := s.redis.LPush(ctx, userSessionsKey(userID), session.ID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add session to user list: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

// Validate checks if a session is valid and returns it
func (s *RedisSessionStore) Validate(ctx context.Context, sessionID string) (*Session, error) <span class="cov0" title="0">{
        data, err := s.redis.Get(ctx, sessionKey(sessionID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session not found or expired")
        }</span>

        <span class="cov0" title="0">var session Session
        if err := json.Unmarshal([]byte(data), &amp;session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal session: %w", err)
        }</span>

        <span class="cov0" title="0">if time.Now().After(session.ExpiresAt) </span><span class="cov0" title="0">{
                _ = s.Revoke(ctx, sessionID)
                return nil, fmt.Errorf("session expired")
        }</span>

        <span class="cov0" title="0">return &amp;session, nil</span>
}

// Revoke invalidates a session by deleting it from Redis
func (s *RedisSessionStore) Revoke(ctx context.Context, sessionID string) error <span class="cov0" title="0">{
        return s.redis.Del(ctx, sessionKey(sessionID))
}</span>

// RevokeAllForUser invalidates all sessions for a user (Global Logout)
func (s *RedisSessionStore) RevokeAllForUser(ctx context.Context, userID string) error <span class="cov0" title="0">{
        // Get all session IDs for the user
        sessionIDs, err := s.redis.LRange(ctx, userSessionsKey(userID), 0, -1)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user sessions: %w", err)
        }</span>

        // Delete each session
        <span class="cov0" title="0">for _, sid := range sessionIDs </span><span class="cov0" title="0">{
                _ = s.redis.Del(ctx, sessionKey(sid))
        }</span>

        // Clear the user's session list
        <span class="cov0" title="0">return s.redis.Del(ctx, userSessionsKey(userID))</span>
}

// ListUserSessions returns all active sessions for a user
func (s *RedisSessionStore) ListUserSessions(ctx context.Context, userID string) ([]Session, error) <span class="cov0" title="0">{
        sessionIDs, err := s.redis.LRange(ctx, userSessionsKey(userID), 0, -1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user sessions: %w", err)
        }</span>

        <span class="cov0" title="0">var sessions []Session
        for _, sid := range sessionIDs </span><span class="cov0" title="0">{
                session, err := s.Validate(ctx, sid)
                if err != nil </span><span class="cov0" title="0">{
                        // Session expired or invalid, skip it
                        continue</span>
                }
                <span class="cov0" title="0">sessions = append(sessions, *session)</span>
        }

        <span class="cov0" title="0">return sessions, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package token

import (
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/auth/domain"
)

type JWTService struct {
        secretKey []byte
        issuer    string
}

func NewJWTService(secret string) *JWTService <span class="cov0" title="0">{
        return &amp;JWTService{
                secretKey: []byte(secret),
                issuer:    "club-pulse-api",
        }
}</span>

func (s *JWTService) GenerateToken(user *domain.User) (*domain.Token, error) <span class="cov0" title="0">{
        expiration := time.Now().Add(24 * time.Hour) // Access Token 24h expiry for MVP/Dev

        claims := jwt.MapClaims{
                "sub":     user.ID,
                "name":    user.Name,
                "role":    user.Role,
                "club_id": user.ClubID,
                "iss":     s.issuer,
                "exp":     expiration.Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        signedToken, err := token.SignedString(s.secretKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">refreshToken, err := s.GenerateRefreshToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;domain.Token{
                AccessToken:  signedToken,
                RefreshToken: refreshToken,
                ExpiresIn:    86400, // 24h
        }, nil</span>
}

func (s *JWTService) GenerateRefreshToken(user *domain.User) (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

func (s *JWTService) ValidateRefreshToken(token string) (string, error) <span class="cov0" title="0">{
        // For opaque tokens, we don't validate in token service (it's a DB lookup)
        // Return the token itself as ID / or mock validation
        return token, nil
}</span>

func (s *JWTService) ValidateToken(tokenString string) (*domain.UserClaims, error) <span class="cov0" title="0">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return s.secretKey, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                sub, okSub := claims["sub"].(string)
                role, _ := claims["role"].(string) // Optional or default to USER
                clubID, _ := claims["club_id"].(string)

                if okSub </span><span class="cov0" title="0">{
                        return &amp;domain.UserClaims{
                                UserID: sub,
                                Role:   role,
                                ClubID: clubID,
                        }, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid token claims")</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package application

import (
        "context"
        "errors"
        "time"

        "github.com/google/uuid"
        bookingDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/domain"
        facilityDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/domain"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/notification/service"
)

// DTOs
type CreateBookingDTO struct {
        UserID     string    `json:"user_id" binding:"required"`
        FacilityID string    `json:"facility_id" binding:"required"`
        StartTime  time.Time `json:"start_time" binding:"required"`
        EndTime    time.Time `json:"end_time" binding:"required"`
}

type CreateRecurringRuleDTO struct {
        FacilityID string                       `json:"facility_id" binding:"required"`
        Type       bookingDomain.RecurrenceType `json:"type" binding:"required"`
        DayOfWeek  int                          `json:"day_of_week" binding:"gte=0,lte=6"`
        StartTime  time.Time                    `json:"start_time" binding:"required"`
        EndTime    time.Time                    `json:"end_time" binding:"required"`
        StartDate  string                       `json:"start_date" binding:"required"` // YYYY-MM-DD
        EndDate    string                       `json:"end_date" binding:"required"`   // YYYY-MM-DD
}

// BookingUseCases handles core booking logic.
// Refactored to follow SOLID principles:
// - Logic separated into private methods (SRP).
// - Depend on interfaces (DIP).
type BookingUseCases struct {
        repo          bookingDomain.BookingRepository
        recurringRepo bookingDomain.RecurringRepository
        facilityRepo  facilityDomain.FacilityRepository
        notifier      service.NotificationSender
}

func NewBookingUseCases(
        repo bookingDomain.BookingRepository,
        recurringRepo bookingDomain.RecurringRepository,
        facilityRepo facilityDomain.FacilityRepository,
        notifier service.NotificationSender,
) *BookingUseCases <span class="cov8" title="1">{
        return &amp;BookingUseCases{
                repo:          repo,
                recurringRepo: recurringRepo,
                facilityRepo:  facilityRepo,
                notifier:      notifier,
        }
}</span>

// CreateBooking orchestrates the booking creation flow: Validate -&gt; Conflict Check -&gt; Persist -&gt; Notify.
func (uc *BookingUseCases) CreateBooking(clubID string, dto CreateBookingDTO) (*bookingDomain.Booking, error) <span class="cov8" title="1">{
        // 1. Parsing &amp; Basic Validation
        userID, facilityID, err := parseBookingIDs(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if dto.StartTime.After(dto.EndTime) </span><span class="cov8" title="1">{
                return nil, errors.New("start time must be before end time")
        }</span>

        // 2. Business Rule Validation (Facility Status &amp; Conflicts)
        <span class="cov8" title="1">if err := uc.validateBookingRules(clubID, dto.FacilityID, facilityID, dto.StartTime, dto.EndTime); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 3. Entity Construction
        <span class="cov8" title="1">booking := &amp;bookingDomain.Booking{
                ID:         uuid.New(),
                UserID:     userID,
                FacilityID: facilityID,
                ClubID:     clubID,
                StartTime:  dto.StartTime,
                EndTime:    dto.EndTime,
                Status:     bookingDomain.BookingStatusConfirmed,
                CreatedAt:  time.Now(),
                UpdatedAt:  time.Now(),
        }

        // 4. Persistence
        if err := uc.repo.Create(booking); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 5. Side Effects (Notifications) - Async
        <span class="cov8" title="1">uc.notifyAsync(userID.String(), booking.ID.String())

        return booking, nil</span>
}

// ListBookings retrieves bookings with optional filtering.
func (uc *BookingUseCases) ListBookings(clubID string, userID string) ([]bookingDomain.Booking, error) <span class="cov0" title="0">{
        filter := make(map[string]interface{})
        if userID != "" </span><span class="cov0" title="0">{
                if uid, err := uuid.Parse(userID); err == nil </span><span class="cov0" title="0">{
                        filter["user_id"] = uid
                }</span>
        }
        <span class="cov0" title="0">return uc.repo.List(clubID, filter)</span>
}

// CancelBooking handles cancellation with authorization check.
func (uc *BookingUseCases) CancelBooking(clubID, bookingID, requestingUserID string) error <span class="cov0" title="0">{
        bID, err := uuid.Parse(bookingID)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("invalid booking id")
        }</span>

        <span class="cov0" title="0">booking, err := uc.repo.GetByID(clubID, bID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if booking == nil </span><span class="cov0" title="0">{
                return errors.New("booking not found")
        }</span>

        // Authorization Check
        <span class="cov0" title="0">if requestingUserID != "" &amp;&amp; booking.UserID.String() != requestingUserID </span><span class="cov0" title="0">{
                return errors.New("unauthorized to cancel this booking")
        }</span>

        <span class="cov0" title="0">booking.Status = bookingDomain.BookingStatusCancelled
        booking.UpdatedAt = time.Now()

        return uc.repo.Update(booking)</span>
}

// GetAvailability calculates available slots based on business hours and existing bookings.
func (uc *BookingUseCases) GetAvailability(clubID, facilityID string, date time.Time) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        facUUID, err := uuid.Parse(facilityID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid facility id")
        }</span>

        // 1. Fetch dependencies (Facility &amp; Existing Bookings)
        // Suggestion: Use errgroup here for parallel fetching in High Performance scenarios.
        <span class="cov0" title="0">facility, err := uc.facilityRepo.GetByID(clubID, facilityID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if facility == nil </span><span class="cov0" title="0">{
                return nil, errors.New("facility not found")
        }</span>

        <span class="cov0" title="0">bookings, err := uc.repo.ListByFacilityAndDate(clubID, facUUID, date)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 2. Calculate Slots
        // TODO(Architect): Move hardcoded hours (8-23) to Facility Configuration domain.
        <span class="cov0" title="0">const startHour, endHour = 8, 23
        var slots []map[string]interface{}

        for h := startHour; h &lt; endHour; h++ </span><span class="cov0" title="0">{
                slotStart := time.Date(date.Year(), date.Month(), date.Day(), h, 0, 0, 0, date.Location())
                slotEnd := slotStart.Add(1 * time.Hour)

                status := uc.determineSlotStatus(clubID, facilityID, slotStart, slotEnd, bookings)

                slots = append(slots, map[string]interface{}{
                        "start_time": slotStart.Format("15:04"),
                        "end_time":   slotEnd.Format("15:04"),
                        "available":  status == "available",
                        "status":     status,
                })
        }</span>

        <span class="cov0" title="0">return slots, nil</span>
}

// CreateRecurringRule creates a pattern for future bookings.
func (uc *BookingUseCases) CreateRecurringRule(clubID string, dto CreateRecurringRuleDTO) (*bookingDomain.RecurringRule, error) <span class="cov0" title="0">{
        facID, err := uuid.Parse(dto.FacilityID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid facility id")
        }</span>

        <span class="cov0" title="0">startD, err := time.Parse("2006-01-02", dto.StartDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid start date format (YYYY-MM-DD)")
        }</span>
        <span class="cov0" title="0">endD, err := time.Parse("2006-01-02", dto.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid end date format (YYYY-MM-DD)")
        }</span>

        <span class="cov0" title="0">rule := &amp;bookingDomain.RecurringRule{
                ID:         uuid.New(),
                FacilityID: facID,
                ClubID:     clubID,
                Type:       dto.Type,
                DayOfWeek:  dto.DayOfWeek,
                StartTime:  dto.StartTime,
                EndTime:    dto.EndTime,
                StartDate:  startD,
                EndDate:    endD,
        }

        if err := uc.recurringRepo.Create(context.Background(), rule); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return rule, nil</span>
}

// GenerateBookingsFromRules looks ahead and materializes recurring bookings.
// Refactored to separate logic from loop complexity.
func (uc *BookingUseCases) GenerateBookingsFromRules(clubID string, weeks int) error <span class="cov0" title="0">{
        ctx := context.Background()
        rules, err := uc.recurringRepo.GetAllActive(ctx, clubID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">horizon := time.Now().AddDate(0, 0, weeks*7)
        generatedCount := 0

        for _, rule := range rules </span><span class="cov0" title="0">{
                bookings := uc.calculateRecurringBookings(rule, horizon)
                for _, bk := range bookings </span><span class="cov0" title="0">{
                        // Check conflict before creation (Double-check safety)
                        conflict, _ := uc.repo.HasTimeConflict(clubID, bk.FacilityID, bk.StartTime, bk.EndTime)
                        if !conflict </span><span class="cov0" title="0">{
                                if err := uc.repo.Create(&amp;bk); err == nil </span><span class="cov0" title="0">{
                                        generatedCount++
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// --- Private Helpers (The "Clean Code" Section) ---

func parseBookingIDs(dto CreateBookingDTO) (uuid.UUID, uuid.UUID, error) <span class="cov8" title="1">{
        usrID, err := uuid.Parse(dto.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, uuid.Nil, errors.New("invalid user id")
        }</span>
        <span class="cov8" title="1">facID, err := uuid.Parse(dto.FacilityID)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, uuid.Nil, errors.New("invalid facility id")
        }</span>
        <span class="cov8" title="1">return usrID, facID, nil</span>
}

func (uc *BookingUseCases) validateBookingRules(clubID, facilityIDStr string, facilityID uuid.UUID, start, end time.Time) error <span class="cov8" title="1">{
        // 1. Check Facility Existence &amp; Status
        facility, err := uc.facilityRepo.GetByID(clubID, facilityIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if facility == nil </span><span class="cov8" title="1">{
                return errors.New("facility not found")
        }</span>
        <span class="cov8" title="1">if facility.Status != facilityDomain.FacilityStatusActive </span><span class="cov0" title="0">{
                return errors.New("facility is not active (current status: " + string(facility.Status) + ")")
        }</span>

        // 2. Check Existing Bookings
        <span class="cov8" title="1">conflict, err := uc.repo.HasTimeConflict(clubID, facilityID, start, end)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if conflict </span><span class="cov8" title="1">{
                return errors.New("booking time conflict: facility is already booked for this requested time")
        }</span>

        // 3. Check Maintenance Schedules
        <span class="cov8" title="1">maintConflict, err := uc.facilityRepo.HasConflict(clubID, facilityIDStr, start, end)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if maintConflict </span><span class="cov8" title="1">{
                return errors.New("booking time conflict: facility is scheduled for maintenance during this time")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *BookingUseCases) notifyAsync(userID, bookingID string) <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                err := uc.notifier.Send(context.Background(), service.Notification{
                        RecipientID: userID,
                        Type:        service.NotificationTypeEmail,
                        Subject:     "Booking Confirmed",
                        Message:     "Booking Confirmed: " + bookingID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        // Logger should be injected, but ignoring for now as per previous lint strategy
                        _ = err
                }</span>
        }()
}

func (uc *BookingUseCases) determineSlotStatus(clubID, facilityID string, start, end time.Time, bookings []bookingDomain.Booking) string <span class="cov0" title="0">{
        // 1. Check Overlap with Bookings
        for _, b := range bookings </span><span class="cov0" title="0">{
                if b.StartTime.Before(end) &amp;&amp; b.EndTime.After(start) </span><span class="cov0" title="0">{
                        return "booked"
                }</span>
        }

        // 2. Check overlap with Maintenance
        // Note: In detailed logic, facilityRepo.HasConflict checks DB.
        // For high performance, maintenance intervals should be pre-fetched along with bookings within the date range,
        // avoiding N+1 queries inside this loop. Keeping N+1 for MVP parity but noting it.
        <span class="cov0" title="0">maint, _ := uc.facilityRepo.HasConflict(clubID, facilityID, start, end)
        if maint </span><span class="cov0" title="0">{
                return "maintenance"
        }</span>

        <span class="cov0" title="0">return "available"</span>
}

func (uc *BookingUseCases) calculateRecurringBookings(rule bookingDomain.RecurringRule, horizon time.Time) []bookingDomain.Booking <span class="cov0" title="0">{
        var bookings []bookingDomain.Booking
        now := time.Now()

        // Determine iteration range
        start := rule.StartDate
        if start.Before(now) </span><span class="cov0" title="0">{
                start = now
        }</span>
        <span class="cov0" title="0">end := rule.EndDate
        if end.After(horizon) </span><span class="cov0" title="0">{
                end = horizon
        }</span>

        // System user ID placeholder (extracted from original code)
        <span class="cov0" title="0">systemUser := uuid.MustParse("00000000-0000-0000-0000-000000000000")

        current := start
        for !current.After(end) </span><span class="cov0" title="0">{
                if int(current.Weekday()) == rule.DayOfWeek </span><span class="cov0" title="0">{
                        // Combine Date(current) + Time(rule.StartTime)
                        y, m, d := current.Date()

                        h, min, s := rule.StartTime.Clock()
                        bookingStart := time.Date(y, m, d, h, min, s, 0, rule.StartTime.Location())

                        hEnd, minEnd, sEnd := rule.EndTime.Clock()
                        bookingEnd := time.Date(y, m, d, hEnd, minEnd, sEnd, 0, rule.EndTime.Location())

                        bookings = append(bookings, bookingDomain.Booking{
                                ID:         uuid.New(),
                                UserID:     systemUser,
                                ClubID:     rule.ClubID,
                                FacilityID: rule.FacilityID,
                                StartTime:  bookingStart,
                                EndTime:    bookingEnd,
                                Status:     bookingDomain.BookingStatusConfirmed,
                                CreatedAt:  now,
                                UpdatedAt:  now,
                        })
                }</span>
                <span class="cov0" title="0">current = current.AddDate(0, 0, 1)</span>
        }

        <span class="cov0" title="0">return bookings</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package cache

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        platformRedis "github.com/lukcba/club-pulse-system-api/backend/internal/platform/redis"
)

// ReservationLock provides temporary locking for booking slots
// This prevents "slot stealing" when a user is completing the booking process
type ReservationLock struct {
        redis *platformRedis.RedisClient
        ttl   time.Duration
}

// LockInfo contains information about a lock
type LockInfo struct {
        LockID     string    `json:"lock_id"`
        FacilityID string    `json:"facility_id"`
        UserID     string    `json:"user_id"`
        StartTime  time.Time `json:"start_time"`
        EndTime    time.Time `json:"end_time"`
        CreatedAt  time.Time `json:"created_at"`
        ExpiresAt  time.Time `json:"expires_at"`
}

// NewReservationLock creates a new reservation lock manager
func NewReservationLock(ttl time.Duration) *ReservationLock <span class="cov0" title="0">{
        return &amp;ReservationLock{
                redis: platformRedis.GetClient(),
                ttl:   ttl,
        }
}</span>

// lockKey generates the Redis key for a slot lock
func lockKey(facilityID string, start, end time.Time) string <span class="cov0" title="0">{
        return fmt.Sprintf("lock:slot:%s:%d:%d", facilityID, start.Unix(), end.Unix())
}</span>

// Acquire attempts to acquire a lock for a specific slot
// Returns the lock ID if successful, empty string if slot is already locked
func (l *ReservationLock) Acquire(ctx context.Context, facilityID, userID string, start, end time.Time) (string, error) <span class="cov0" title="0">{
        lockID := uuid.New().String()
        key := lockKey(facilityID, start, end)

        // Use SETNX to ensure only one lock can be created
        acquired, err := l.redis.SetNX(ctx, key, lockID, l.ttl)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to acquire lock: %w", err)
        }</span>

        <span class="cov0" title="0">if !acquired </span><span class="cov0" title="0">{
                return "", fmt.Errorf("slot already locked by another user")
        }</span>

        // Store additional lock info (optional, for debugging/admin)
        <span class="cov0" title="0">infoKey := fmt.Sprintf("lock:info:%s", lockID)
        info := fmt.Sprintf("%s|%s|%s|%d|%d",
                facilityID, userID, lockID, start.Unix(), end.Unix())
        _ = l.redis.Set(ctx, infoKey, info, l.ttl)

        return lockID, nil</span>
}

// Release removes a lock for a specific slot
func (l *ReservationLock) Release(ctx context.Context, facilityID string, start, end time.Time) error <span class="cov0" title="0">{
        key := lockKey(facilityID, start, end)
        return l.redis.Del(ctx, key)
}</span>

// ReleaseByID releases a lock by its ID (verifies ownership)
func (l *ReservationLock) ReleaseByID(ctx context.Context, lockID, facilityID string, start, end time.Time) error <span class="cov0" title="0">{
        key := lockKey(facilityID, start, end)

        // Get the current lock value
        currentLock, err := l.redis.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("lock not found or expired")
        }</span>

        // Verify ownership
        <span class="cov0" title="0">if currentLock != lockID </span><span class="cov0" title="0">{
                return fmt.Errorf("lock owned by different user")
        }</span>

        // Delete the lock
        <span class="cov0" title="0">if err := l.redis.Del(ctx, key); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to release lock: %w", err)
        }</span>

        // Clean up info key
        <span class="cov0" title="0">infoKey := fmt.Sprintf("lock:info:%s", lockID)
        _ = l.redis.Del(ctx, infoKey)

        return nil</span>
}

// IsLocked checks if a specific slot is currently locked
func (l *ReservationLock) IsLocked(ctx context.Context, facilityID string, start, end time.Time) (bool, error) <span class="cov0" title="0">{
        key := lockKey(facilityID, start, end)
        exists, err := l.redis.Exists(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                // If Redis fails, assume not locked (fail open for availability)
                return false, nil
        }</span>
        <span class="cov0" title="0">return exists, nil</span>
}

// ExtendLock extends the TTL of an existing lock
func (l *ReservationLock) ExtendLock(ctx context.Context, lockID, facilityID string, start, end time.Time) error <span class="cov0" title="0">{
        key := lockKey(facilityID, start, end)

        // Get the current lock value
        currentLock, err := l.redis.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("lock not found or expired")
        }</span>

        // Verify ownership
        <span class="cov0" title="0">if currentLock != lockID </span><span class="cov0" title="0">{
                return fmt.Errorf("lock owned by different user")
        }</span>

        // Extend the TTL
        <span class="cov0" title="0">return l.redis.Expire(ctx, key, l.ttl)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package http

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/application"
)

type BookingHandler struct {
        useCases *application.BookingUseCases
}

func NewBookingHandler(useCases *application.BookingUseCases) *BookingHandler <span class="cov0" title="0">{
        return &amp;BookingHandler{
                useCases: useCases,
        }
}</span>

func RegisterRoutes(r *gin.RouterGroup, handler *BookingHandler, authMiddleware, tenantMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        bookings := r.Group("/bookings")
        bookings.Use(authMiddleware, tenantMiddleware)
        </span><span class="cov0" title="0">{
                bookings.POST("", handler.Create)
                bookings.GET("", handler.List)
                bookings.GET("/availability", handler.GetAvailability)
                bookings.DELETE("/:id", handler.Cancel)
                bookings.POST("/recurring", handler.CreateRecurringRule)
                bookings.POST("/generate", handler.GenerateBookings)
        }</span>
}

func (h *BookingHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">var dto application.CreateBookingDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Override input userID with authenticated userID to prevent spoofing
        <span class="cov0" title="0">dto.UserID = userID.(string)

        clubID := c.GetString("clubID")
        booking, err := h.useCases.CreateBooking(clubID, dto)
        if err != nil </span><span class="cov0" title="0">{
                // Differentiate connection vs conflict vs validation errors properly in a real app
                // For MVP, if error message contains "conflict", return 409
                if err.Error() == "booking time conflict: facility is already booked for this requested time" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, booking)</span>
}

func (h *BookingHandler) List(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        // By default list own bookings
        // Admin logic could be added here later
        <span class="cov0" title="0">clubID := c.GetString("clubID")
        bookings, err := h.useCases.ListBookings(clubID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": bookings})</span>
}

func (h *BookingHandler) Cancel(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">bookingID := c.Param("id")
        if bookingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "booking id required"})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        if err := h.useCases.CancelBooking(clubID, bookingID, userID.(string)); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "booking cancelled"})</span>
}

func (h *BookingHandler) GetAvailability(c *gin.Context) <span class="cov0" title="0">{
        // 1. Parse params
        facilityID := c.Query("facility_id")
        dateStr := c.Query("date")

        if facilityID == "" || dateStr == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "facility_id and date are required"})
                return
        }</span>

        <span class="cov0" title="0">date, err := time.Parse("2006-01-02", dateStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid date format (expected YYYY-MM-DD)"})
                return
        }</span>

        // 2. Call UseCase
        <span class="cov0" title="0">clubID := c.GetString("clubID")
        availability, err := h.useCases.GetAvailability(clubID, facilityID, date)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": availability})</span>
}

func (h *BookingHandler) CreateRecurringRule(c *gin.Context) <span class="cov0" title="0">{
        // Simple RBAC check (MVP: hardcode checks or assume middleware handles basic auth)
        // In production: check if user is admin/manager

        var dto application.CreateRecurringRuleDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        rule, err := h.useCases.CreateRecurringRule(clubID, dto)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, rule)</span>
}

func (h *BookingHandler) GenerateBookings(c *gin.Context) <span class="cov0" title="0">{
        // Admin only
        // Check query param for weeks
        // weeks := c.Query("weeks") ... parse int
        clubID := c.GetString("clubID")

        if err := h.useCases.GenerateBookingsFromRules(clubID, 4); err != nil </span><span class="cov0" title="0">{ // Default 4 weeks
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "bookings generated successfully"})</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package lock

import (
        "context"
        "fmt"
        "time"

        platformRedis "github.com/lukcba/club-pulse-system-api/backend/internal/platform/redis"
)

// BookingLock provides distributed locking for booking slots
// Prevents race conditions when multiple users try to book the same slot
type BookingLock struct {
        redis *platformRedis.RedisClient
}

// NewBookingLock creates a new booking lock service
func NewBookingLock() *BookingLock <span class="cov0" title="0">{
        return &amp;BookingLock{
                redis: platformRedis.GetClient(),
        }
}</span>

// lockKey generates a unique key for a facility/time slot combination
func lockKey(facilityID string, start, end time.Time) string <span class="cov0" title="0">{
        return fmt.Sprintf("booking_lock:%s:%d:%d",
                facilityID,
                start.Unix(),
                end.Unix(),
        )
}</span>

// AcquireLock attempts to acquire a lock for a booking slot
// Returns true if lock acquired, false if slot is already locked by another user
// TTL is the maximum time the lock will be held (e.g., 5 minutes for checkout flow)
func (l *BookingLock) AcquireLock(ctx context.Context, facilityID string, start, end time.Time, userID string, ttl time.Duration) (bool, error) <span class="cov0" title="0">{
        key := lockKey(facilityID, start, end)

        // Try to set the lock (SetNX = SET if Not eXists)
        acquired, err := l.redis.SetNX(ctx, key, userID, ttl)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to acquire booking lock: %w", err)
        }</span>

        <span class="cov0" title="0">return acquired, nil</span>
}

// ReleaseLock releases a booking lock
func (l *BookingLock) ReleaseLock(ctx context.Context, facilityID string, start, end time.Time) error <span class="cov0" title="0">{
        key := lockKey(facilityID, start, end)
        return l.redis.Del(ctx, key)
}</span>

// IsLocked checks if a slot is currently locked
func (l *BookingLock) IsLocked(ctx context.Context, facilityID string, start, end time.Time) (bool, error) <span class="cov0" title="0">{
        key := lockKey(facilityID, start, end)
        return l.redis.Exists(ctx, key)
}</span>

// GetLockHolder returns the user ID holding the lock, or empty string if unlocked
func (l *BookingLock) GetLockHolder(ctx context.Context, facilityID string, start, end time.Time) (string, error) <span class="cov0" title="0">{
        key := lockKey(facilityID, start, end)
        userID, err := l.redis.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                // redis.Nil error means key doesn't exist
                return "", nil
        }</span>
        <span class="cov0" title="0">return userID, nil</span>
}

// ExtendLock extends the TTL of an existing lock (for long checkout processes)
func (l *BookingLock) ExtendLock(ctx context.Context, facilityID string, start, end time.Time, additionalTTL time.Duration) error <span class="cov0" title="0">{
        key := lockKey(facilityID, start, end)
        return l.redis.Expire(ctx, key, additionalTTL)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package repository

import (
        "time"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/domain"
        "gorm.io/gorm"
)

type PostgresBookingRepository struct {
        db *gorm.DB
}

func NewPostgresBookingRepository(db *gorm.DB) domain.BookingRepository <span class="cov0" title="0">{
        _ = db.AutoMigrate(&amp;domain.Booking{})
        return &amp;PostgresBookingRepository{db: db}
}</span>

func (r *PostgresBookingRepository) Create(booking *domain.Booking) error <span class="cov0" title="0">{
        return r.db.Create(booking).Error
}</span>

func (r *PostgresBookingRepository) GetByID(clubID string, id uuid.UUID) (*domain.Booking, error) <span class="cov0" title="0">{
        var booking domain.Booking
        if err := r.db.First(&amp;booking, "id = ? AND club_id = ?", id, clubID).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;booking, nil</span>
}

func (r *PostgresBookingRepository) List(clubID string, filter map[string]interface{}) ([]domain.Booking, error) <span class="cov0" title="0">{
        var bookings []domain.Booking
        query := r.db.Model(&amp;domain.Booking{}).Where("club_id = ?", clubID)

        for key, value := range filter </span><span class="cov0" title="0">{
                query = query.Where(key+" = ?", value)
        }</span>
        // Default sort by start time desc
        <span class="cov0" title="0">query = query.Order("start_time desc")

        if err := query.Find(&amp;bookings).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return bookings, nil</span>
}

func (r *PostgresBookingRepository) Update(booking *domain.Booking) error <span class="cov0" title="0">{
        return r.db.Save(booking).Error
}</span>

func (r *PostgresBookingRepository) HasTimeConflict(clubID string, facilityID uuid.UUID, start, end time.Time) (bool, error) <span class="cov0" title="0">{
        var count int64
        // Check for any confirmed booking that overlaps with [start, end)
        // Overlap condition: (ExistingStart &lt; NewEnd) AND (ExistingEnd &gt; NewStart)
        err := r.db.Model(&amp;domain.Booking{}).
                Where("club_id = ?", clubID).
                Where("facility_id = ?", facilityID).
                Where("status = ?", domain.BookingStatusConfirmed).
                Where("start_time &lt; ?", end).
                Where("end_time &gt; ?", start).
                Count(&amp;count).Error

        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (r *PostgresBookingRepository) ListByFacilityAndDate(clubID string, facilityID uuid.UUID, date time.Time) ([]domain.Booking, error) <span class="cov0" title="0">{
        var bookings []domain.Booking
        // Filter by facility and date range (start of day to end of day)
        startOfDay := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())
        endOfDay := startOfDay.Add(24 * time.Hour)

        // We want bookings that overlap with this day (though usually bookings are contained within a day)
        // Simple overlap check: Start &lt; EndOfDay AND End &gt; StartOfDay
        err := r.db.Model(&amp;domain.Booking{}).
                Where("club_id = ?", clubID).
                Where("facility_id = ?", facilityID).
                Where("status = ?", domain.BookingStatusConfirmed).
                Where("start_time &lt; ?", endOfDay).
                Where("end_time &gt; ?", startOfDay).
                Order("start_time asc").
                Find(&amp;bookings).Error

        return bookings, err
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package repository

import (
        "context"
        "time"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/booking/domain"
        "gorm.io/gorm"
)

type PostgresRecurringRepository struct {
        db *gorm.DB
}

func NewPostgresRecurringRepository(db *gorm.DB) *PostgresRecurringRepository <span class="cov0" title="0">{
        return &amp;PostgresRecurringRepository{db: db}
}</span>

func (r *PostgresRecurringRepository) Create(ctx context.Context, rule *domain.RecurringRule) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(rule).Error
}</span>

func (r *PostgresRecurringRepository) GetByFacility(ctx context.Context, clubID string, facilityID uuid.UUID) ([]domain.RecurringRule, error) <span class="cov0" title="0">{
        var rules []domain.RecurringRule
        err := r.db.WithContext(ctx).
                Where("club_id = ? AND facility_id = ?", clubID, facilityID).
                Find(&amp;rules).Error
        return rules, err
}</span>

// GetAllActive returns rules that are currently valid (EndDate &gt;= Today)
func (r *PostgresRecurringRepository) GetAllActive(ctx context.Context, clubID string) ([]domain.RecurringRule, error) <span class="cov0" title="0">{
        var rules []domain.RecurringRule
        today := time.Now().Truncate(24 * time.Hour)
        err := r.db.WithContext(ctx).
                Where("club_id = ? AND end_date &gt;= ?", clubID, today).
                Find(&amp;rules).Error
        return rules, err
}</span>

func (r *PostgresRecurringRepository) Delete(ctx context.Context, clubID string, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;domain.RecurringRule{}, "id = ? AND club_id = ?", id, clubID).Error
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package application

import (
        "errors"

        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/club/domain"
)

type ClubDTO struct {
        ID       string            `json:"id"`
        Name     string            `json:"name"`
        Domain   string            `json:"domain"`
        Status   domain.ClubStatus `json:"status"`
        Settings string            `json:"settings"`
}

type CreateClubDTO struct {
        ID       string `json:"id" binding:"required"` // Slug
        Name     string `json:"name" binding:"required"`
        Domain   string `json:"domain"`
        Settings string `json:"settings"`
}

type UpdateClubDTO struct {
        Name     string            `json:"name"`
        Domain   string            `json:"domain"`
        Status   domain.ClubStatus `json:"status"`
        Settings string            `json:"settings"`
}

type ClubUseCases struct {
        repo domain.ClubRepository
}

func NewClubUseCases(repo domain.ClubRepository) *ClubUseCases <span class="cov0" title="0">{
        return &amp;ClubUseCases{repo: repo}
}</span>

func (uc *ClubUseCases) CreateClub(dto CreateClubDTO) (*domain.Club, error) <span class="cov0" title="0">{
        // Check if ID already exists
        existing, err := uc.repo.GetByID(dto.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                return nil, errors.New("club ID already exists")
        }</span>

        <span class="cov0" title="0">club := &amp;domain.Club{
                ID:       dto.ID,
                Name:     dto.Name,
                Domain:   dto.Domain,
                Status:   domain.ClubStatusActive,
                Settings: dto.Settings,
        }

        if err := uc.repo.Create(club); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return club, nil</span>
}

func (uc *ClubUseCases) UpdateClub(id string, dto UpdateClubDTO) (*domain.Club, error) <span class="cov0" title="0">{
        club, err := uc.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if club == nil </span><span class="cov0" title="0">{
                return nil, errors.New("club not found")
        }</span>

        <span class="cov0" title="0">if dto.Name != "" </span><span class="cov0" title="0">{
                club.Name = dto.Name
        }</span>
        <span class="cov0" title="0">if dto.Domain != "" </span><span class="cov0" title="0">{
                club.Domain = dto.Domain
        }</span>
        <span class="cov0" title="0">if dto.Status != "" </span><span class="cov0" title="0">{
                club.Status = dto.Status
        }</span>
        <span class="cov0" title="0">if dto.Settings != "" </span><span class="cov0" title="0">{
                club.Settings = dto.Settings
        }</span>

        <span class="cov0" title="0">if err := uc.repo.Update(club); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return club, nil</span>
}

func (uc *ClubUseCases) GetClub(id string) (*domain.Club, error) <span class="cov0" title="0">{
        return uc.repo.GetByID(id)
}</span>

func (uc *ClubUseCases) ListClubs(limit, offset int) ([]domain.Club, error) <span class="cov0" title="0">{
        return uc.repo.List(limit, offset)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package http

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/club/application"
        userDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/domain"
)

type ClubHandler struct {
        uc *application.ClubUseCases
}

func NewClubHandler(uc *application.ClubUseCases) *ClubHandler <span class="cov0" title="0">{
        return &amp;ClubHandler{uc: uc}
}</span>

// CreateClub godoc
// @Summary Create a new club (Super Admin only)
// @Description Creates a new tenant
// @Tags clubs
// @Accept json
// @Produce json
// @Success 201 {object} domain.Club
// @Router /clubs [post]
func (h *ClubHandler) CreateClub(c *gin.Context) <span class="cov0" title="0">{
        if !h.isSuperAdmin(c) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "requires SUPER_ADMIN role"})
                return
        }</span>

        <span class="cov0" title="0">var req application.CreateClubDTO
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">club, err := h.uc.CreateClub(req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, club)</span>
}

// ListClubs godoc
// @Summary List all clubs (Super Admin only)
// @Description Lists all tenants
// @Tags clubs
// @Produce json
// @Success 200 {array} domain.Club
// @Router /clubs [get]
func (h *ClubHandler) ListClubs(c *gin.Context) <span class="cov0" title="0">{
        if !h.isSuperAdmin(c) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "requires SUPER_ADMIN role"})
                return
        }</span>

        <span class="cov0" title="0">limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        clubs, err := h.uc.ListClubs(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, clubs)</span>
}

// UpdateClub godoc
// @Summary Update a club (Super Admin only)
// @Description Updates tenant details
// @Tags clubs
// @Accept json
// @Produce json
// @Router /clubs/{id} [put]
func (h *ClubHandler) UpdateClub(c *gin.Context) <span class="cov0" title="0">{
        if !h.isSuperAdmin(c) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "requires SUPER_ADMIN role"})
                return
        }</span>

        <span class="cov0" title="0">id := c.Param("id")
        var req application.UpdateClubDTO
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">club, err := h.uc.UpdateClub(id, req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, club)</span>
}

func (h *ClubHandler) isSuperAdmin(c *gin.Context) bool <span class="cov0" title="0">{
        // 1. Check if userRole is set in context (from AuthMiddleware)
        role, exists := c.Get("userRole")
        if !exists </span><span class="cov0" title="0">{
                // Fallback: Check if we can get it from DB if we have userID?
                // Ideally, AuthMiddleware should set this.
                return false
        }</span>
        <span class="cov0" title="0">return role == userDomain.RoleSuperAdmin</span>
}

func RegisterRoutes(r *gin.RouterGroup, h *ClubHandler, authMiddleware, tenantMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        clubs := r.Group("/clubs")
        clubs.Use(authMiddleware, tenantMiddleware)
        </span><span class="cov0" title="0">{
                clubs.POST("", h.CreateClub)
                clubs.GET("", h.ListClubs)
                clubs.PUT("/:id", h.UpdateClub)
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package repository

import (
        "errors"
        "time"

        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/club/domain"
        "gorm.io/gorm"
)

type PostgresClubRepository struct {
        db *gorm.DB
}

func NewPostgresClubRepository(db *gorm.DB) *PostgresClubRepository <span class="cov0" title="0">{
        _ = db.AutoMigrate(&amp;domain.Club{})
        return &amp;PostgresClubRepository{db: db}
}</span>

func (r *PostgresClubRepository) Create(club *domain.Club) error <span class="cov0" title="0">{
        if club.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                club.CreatedAt = time.Now()
        }</span>
        <span class="cov0" title="0">if club.UpdatedAt.IsZero() </span><span class="cov0" title="0">{
                club.UpdatedAt = time.Now()
        }</span>
        <span class="cov0" title="0">return r.db.Create(club).Error</span>
}

func (r *PostgresClubRepository) GetByID(id string) (*domain.Club, error) <span class="cov0" title="0">{
        var club domain.Club
        if err := r.db.First(&amp;club, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;club, nil</span>
}

func (r *PostgresClubRepository) List(limit, offset int) ([]domain.Club, error) <span class="cov0" title="0">{
        var clubs []domain.Club
        if err := r.db.Limit(limit).Offset(offset).Find(&amp;clubs).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return clubs, nil</span>
}

func (r *PostgresClubRepository) Update(club *domain.Club) error <span class="cov0" title="0">{
        club.UpdatedAt = time.Now()
        return r.db.Save(club).Error
}</span>

func (r *PostgresClubRepository) Delete(id string) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;domain.Club{}, "id = ?", id).Error
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package application

import (
        "errors"
        "time"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/disciplines/domain"
        userDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/domain"
)

type DisciplineUseCases struct {
        repo           domain.DisciplineRepository
        tournamentRepo domain.TournamentRepository
        userRepo       userDomain.UserRepository
}

func NewDisciplineUseCases(repo domain.DisciplineRepository, tournamentRepo domain.TournamentRepository, userRepo userDomain.UserRepository) *DisciplineUseCases <span class="cov0" title="0">{
        return &amp;DisciplineUseCases{
                repo:           repo,
                tournamentRepo: tournamentRepo,
                userRepo:       userRepo,
        }
}</span>

func (uc *DisciplineUseCases) CreateDiscipline(clubID string, name, description string) (*domain.Discipline, error) <span class="cov0" title="0">{
        d := &amp;domain.Discipline{
                ID:          uuid.New(),
                ClubID:      clubID,
                Name:        name,
                Description: description,
                IsActive:    true,
        }
        if err := uc.repo.CreateDiscipline(d); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return d, nil</span>
}

func (uc *DisciplineUseCases) CreateGroup(clubID string, name string, dID uuid.UUID, category, coachID, schedule string) (*domain.TrainingGroup, error) <span class="cov0" title="0">{
        g := &amp;domain.TrainingGroup{
                ID:           uuid.New(),
                ClubID:       clubID,
                Name:         name,
                DisciplineID: dID,
                Category:     category,
                CoachID:      coachID,
                Schedule:     schedule,
        }
        if err := uc.repo.CreateGroup(g); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return g, nil</span>
}

func (uc *DisciplineUseCases) ListDisciplines(clubID string) ([]domain.Discipline, error) <span class="cov0" title="0">{
        return uc.repo.ListDisciplines(clubID)
}</span>

func (uc *DisciplineUseCases) ListGroups(clubID string, disciplineID string, category string) ([]domain.TrainingGroup, error) <span class="cov0" title="0">{
        filter := make(map[string]interface{})
        if disciplineID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(disciplineID)
                if err == nil </span><span class="cov0" title="0">{
                        filter["discipline_id"] = id
                }</span>
        }
        <span class="cov0" title="0">if category != "" </span><span class="cov0" title="0">{
                filter["category"] = category
        }</span>
        <span class="cov0" title="0">return uc.repo.ListGroups(clubID, filter)</span>
}

func (uc *DisciplineUseCases) ListStudentsInGroup(clubID string, groupID uuid.UUID) ([]userDomain.User, error) <span class="cov0" title="0">{
        group, err := uc.repo.GetGroupByID(clubID, groupID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if group == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Filter users by the group's category (year of birth)
        // We use the User module's List method with the "category" filter.
        <span class="cov0" title="0">return uc.userRepo.List(clubID, 100, 0, map[string]interface{}{"category": group.Category})</span>
}

// --- Championships ---

func (uc *DisciplineUseCases) CreateTournament(clubID string, name, disciplineID string, startDate, endDate time.Time, format string) (*domain.Tournament, error) <span class="cov0" title="0">{
        dID, err := uuid.Parse(disciplineID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">t := &amp;domain.Tournament{
                ID:           uuid.New(),
                ClubID:       clubID,
                Name:         name,
                DisciplineID: dID,
                StartDate:    startDate,
                EndDate:      endDate,
                Status:       domain.TournamentStatusOpen,
                Format:       format,
        }
        if err := uc.tournamentRepo.CreateTournament(t); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return t, nil</span>
}

func (uc *DisciplineUseCases) ListTournaments(clubID string) ([]domain.Tournament, error) <span class="cov0" title="0">{
        return uc.tournamentRepo.ListTournaments(clubID)
}</span>

func (uc *DisciplineUseCases) RegisterTeam(clubID, tournamentID string, name string, captainID string, memberIDs []string) (*domain.Team, error) <span class="cov0" title="0">{
        tID, err := uuid.Parse(tournamentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">team := &amp;domain.Team{
                ID:           uuid.New(),
                ClubID:       clubID,
                TournamentID: tID,
                Name:         name,
                Members:      memberIDs,
        }
        if captainID != "" </span><span class="cov0" title="0">{
                team.CaptainID = &amp;captainID
        }</span>

        <span class="cov0" title="0">if err := uc.tournamentRepo.CreateTeam(team); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return team, nil</span>
}

func (uc *DisciplineUseCases) ScheduleMatch(clubID, tournamentID, homeTeamID, awayTeamID string, startTime time.Time, location, round string) (*domain.Match, error) <span class="cov0" title="0">{
        tID, err := uuid.Parse(tournamentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">hID, err := uuid.Parse(homeTeamID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">aID, err := uuid.Parse(awayTeamID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">match := &amp;domain.Match{
                ID:           uuid.New(),
                ClubID:       clubID,
                TournamentID: tID,
                HomeTeamID:   hID,
                AwayTeamID:   aID,
                StartTime:    startTime,
                Location:     location,
                Round:        round,
                Status:       domain.MatchStatusScheduled,
        }

        if err := uc.tournamentRepo.CreateMatch(match); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return match, nil</span>
}

func (uc *DisciplineUseCases) UpdateMatchResult(clubID, matchID string, scoreHome, scoreAway int) (*domain.Match, error) <span class="cov0" title="0">{
        mID, err := uuid.Parse(matchID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">match, err := uc.tournamentRepo.GetMatchByID(clubID, mID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if match == nil </span><span class="cov0" title="0">{
                return nil, errors.New("match not found")
        }</span>

        <span class="cov0" title="0">match.ScoreHome = scoreHome
        match.ScoreAway = scoreAway
        match.Status = domain.MatchStatusPlayed
        match.UpdatedAt = time.Now()

        if err := uc.tournamentRepo.UpdateMatch(match); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return match, nil</span>
}

func (uc *DisciplineUseCases) GetStandings(clubID, tournamentID string) ([]domain.Standing, error) <span class="cov0" title="0">{
        tID, err := uuid.Parse(tournamentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return uc.tournamentRepo.GetStandings(clubID, tID)</span>
}

func (uc *DisciplineUseCases) ListMatches(clubID, tournamentID string) ([]domain.Match, error) <span class="cov0" title="0">{
        tID, err := uuid.Parse(tournamentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return uc.tournamentRepo.ListMatches(clubID, tID)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package http

import (
        "net/http"

        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/disciplines/application"
)

type DisciplineHandler struct {
        useCases *application.DisciplineUseCases
}

func NewDisciplineHandler(useCases *application.DisciplineUseCases) *DisciplineHandler <span class="cov0" title="0">{
        return &amp;DisciplineHandler{useCases: useCases}
}</span>

func (h *DisciplineHandler) ListDisciplines(c *gin.Context) <span class="cov0" title="0">{
        clubID := c.GetString("clubID")
        disciplines, err := h.useCases.ListDisciplines(clubID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, disciplines)</span>
}

func (h *DisciplineHandler) ListGroups(c *gin.Context) <span class="cov0" title="0">{
        clubID := c.GetString("clubID")
        disciplineID := c.Query("discipline_id")
        category := c.Query("category")
        groups, err := h.useCases.ListGroups(clubID, disciplineID, category)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, groups)</span>
}

func (h *DisciplineHandler) ListStudentsInGroup(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid group id"})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        students, err := h.useCases.ListStudentsInGroup(clubID, id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, students)</span>
}

// --- Championships ---

type CreateTournamentRequest struct {
        Name         string `json:"name" binding:"required"`
        DisciplineID string `json:"discipline_id" binding:"required"`
        StartDate    string `json:"start_date" binding:"required"` // YYYY-MM-DD
        EndDate      string `json:"end_date" binding:"required"`   // YYYY-MM-DD
        Format       string `json:"format" binding:"required"`
}

func (h *DisciplineHandler) CreateTournament(c *gin.Context) <span class="cov0" title="0">{
        var req CreateTournamentRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">start, err := time.Parse("2006-01-02", req.StartDate)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid start date"})
                return
        }</span>
        <span class="cov0" title="0">end, err := time.Parse("2006-01-02", req.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid end date"})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        t, err := h.useCases.CreateTournament(clubID, req.Name, req.DisciplineID, start, end, req.Format)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusCreated, t)</span>
}

func (h *DisciplineHandler) ListTournaments(c *gin.Context) <span class="cov0" title="0">{
        clubID := c.GetString("clubID")
        tournaments, err := h.useCases.ListTournaments(clubID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, tournaments)</span>
}

type RegisterTeamRequest struct {
        Name      string   `json:"name" binding:"required"`
        CaptainID string   `json:"captain_id"`
        MemberIDs []string `json:"member_ids"`
}

func (h *DisciplineHandler) RegisterTeam(c *gin.Context) <span class="cov0" title="0">{
        tournamentID := c.Param("id")
        var req RegisterTeamRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        team, err := h.useCases.RegisterTeam(clubID, tournamentID, req.Name, req.CaptainID, req.MemberIDs)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusCreated, team)</span>
}

type ScheduleMatchRequest struct {
        HomeTeamID string    `json:"home_team_id" binding:"required"`
        AwayTeamID string    `json:"away_team_id" binding:"required"`
        StartTime  time.Time `json:"start_time" binding:"required"`
        Location   string    `json:"location"`
        Round      string    `json:"round"`
}

func (h *DisciplineHandler) ScheduleMatch(c *gin.Context) <span class="cov0" title="0">{
        tournamentID := c.Param("id")
        var req ScheduleMatchRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        match, err := h.useCases.ScheduleMatch(clubID, tournamentID, req.HomeTeamID, req.AwayTeamID, req.StartTime, req.Location, req.Round)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusCreated, match)</span>
}

func (h *DisciplineHandler) ListMatches(c *gin.Context) <span class="cov0" title="0">{
        tournamentID := c.Param("id")
        clubID := c.GetString("clubID")
        matches, err := h.useCases.ListMatches(clubID, tournamentID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, matches)</span>
}

type UpdateMatchResultRequest struct {
        ScoreHome int `json:"score_home"`
        ScoreAway int `json:"score_away"`
}

func (h *DisciplineHandler) UpdateMatchResult(c *gin.Context) <span class="cov0" title="0">{
        matchID := c.Param("id")
        var req UpdateMatchResultRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        match, err := h.useCases.UpdateMatchResult(clubID, matchID, req.ScoreHome, req.ScoreAway)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, match)</span>
}

func (h *DisciplineHandler) GetStandings(c *gin.Context) <span class="cov0" title="0">{
        tournamentID := c.Param("id")
        clubID := c.GetString("clubID")
        standings, err := h.useCases.GetStandings(clubID, tournamentID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, standings)</span>
}

func RegisterRoutes(r *gin.RouterGroup, handler *DisciplineHandler, authMiddleware, tenantMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        r.Use(authMiddleware, tenantMiddleware)
        disciplines := r.Group("/disciplines")
        </span><span class="cov0" title="0">{
                disciplines.GET("", handler.ListDisciplines)
        }</span>

        <span class="cov0" title="0">groups := r.Group("/groups")
        </span><span class="cov0" title="0">{
                groups.GET("", handler.ListGroups)
                groups.GET("/:id/students", handler.ListStudentsInGroup)
        }</span>

        <span class="cov0" title="0">tournaments := r.Group("/tournaments")
        </span><span class="cov0" title="0">{
                tournaments.POST("", handler.CreateTournament)
                tournaments.GET("", handler.ListTournaments)
                tournaments.POST("/:id/teams", handler.RegisterTeam)
                tournaments.POST("/:id/matches", handler.ScheduleMatch)
                tournaments.GET("/:id/matches", handler.ListMatches)
                tournaments.GET("/:id/standings", handler.GetStandings)
        }</span>

        <span class="cov0" title="0">matches := r.Group("/matches")
        </span><span class="cov0" title="0">{
                matches.PUT("/:id/result", handler.UpdateMatchResult)
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package repository

import (
        "errors"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/disciplines/domain"
        "gorm.io/gorm"
)

type PostgresTournamentRepository struct {
        db *gorm.DB
}

func NewPostgresTournamentRepository(db *gorm.DB) *PostgresTournamentRepository <span class="cov0" title="0">{
        _ = db.AutoMigrate(&amp;domain.Tournament{}, &amp;domain.Team{}, &amp;domain.Match{})
        return &amp;PostgresTournamentRepository{db: db}
}</span>

// --- Tournament ---

func (r *PostgresTournamentRepository) CreateTournament(tournament *domain.Tournament) error <span class="cov0" title="0">{
        return r.db.Create(tournament).Error
}</span>

func (r *PostgresTournamentRepository) GetTournamentByID(clubID string, id uuid.UUID) (*domain.Tournament, error) <span class="cov0" title="0">{
        var tournament domain.Tournament
        if err := r.db.Preload("Teams").Preload("Matches").First(&amp;tournament, "id = ? AND club_id = ?", id, clubID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;tournament, nil</span>
}

func (r *PostgresTournamentRepository) ListTournaments(clubID string) ([]domain.Tournament, error) <span class="cov0" title="0">{
        var tournaments []domain.Tournament
        err := r.db.Where("club_id = ?", clubID).Find(&amp;tournaments).Error
        return tournaments, err
}</span>

func (r *PostgresTournamentRepository) UpdateTournament(tournament *domain.Tournament) error <span class="cov0" title="0">{
        return r.db.Save(tournament).Error
}</span>

// --- Team ---

func (r *PostgresTournamentRepository) CreateTeam(team *domain.Team) error <span class="cov0" title="0">{
        return r.db.Create(team).Error
}</span>

func (r *PostgresTournamentRepository) GetTeamByID(clubID string, id uuid.UUID) (*domain.Team, error) <span class="cov0" title="0">{
        var team domain.Team
        if err := r.db.First(&amp;team, "id = ? AND club_id = ?", id, clubID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;team, nil</span>
}

func (r *PostgresTournamentRepository) ListTeams(clubID string, tournamentID uuid.UUID) ([]domain.Team, error) <span class="cov0" title="0">{
        var teams []domain.Team
        err := r.db.Where("tournament_id = ? AND club_id = ?", tournamentID, clubID).Find(&amp;teams).Error
        return teams, err
}</span>

// --- Match ---

func (r *PostgresTournamentRepository) CreateMatch(match *domain.Match) error <span class="cov0" title="0">{
        return r.db.Create(match).Error
}</span>

func (r *PostgresTournamentRepository) UpdateMatch(match *domain.Match) error <span class="cov0" title="0">{
        return r.db.Save(match).Error
}</span>

func (r *PostgresTournamentRepository) GetMatchByID(clubID string, id uuid.UUID) (*domain.Match, error) <span class="cov0" title="0">{
        var match domain.Match
        if err := r.db.First(&amp;match, "id = ? AND club_id = ?", id, clubID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;match, nil</span>
}

func (r *PostgresTournamentRepository) ListMatches(clubID string, tournamentID uuid.UUID) ([]domain.Match, error) <span class="cov0" title="0">{
        var matches []domain.Match
        err := r.db.Where("tournament_id = ? AND club_id = ?", tournamentID, clubID).Order("start_time asc").Find(&amp;matches).Error
        return matches, err
}</span>

// --- Standings ---

func (r *PostgresTournamentRepository) GetStandings(clubID string, tournamentID uuid.UUID) ([]domain.Standing, error) <span class="cov0" title="0">{
        // 1. Get all matches for tournament
        matches, err := r.ListMatches(clubID, tournamentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 2. Get all teams to initialize map
        <span class="cov0" title="0">teams, err := r.ListTeams(clubID, tournamentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">standingMap := make(map[uuid.UUID]*domain.Standing)
        for _, team := range teams </span><span class="cov0" title="0">{
                standingMap[team.ID] = &amp;domain.Standing{
                        TournamentID: tournamentID,
                        TeamID:       team.ID,
                        TeamName:     team.Name,
                }
        }</span>

        // 3. Iterate matches
        <span class="cov0" title="0">for _, m := range matches </span><span class="cov0" title="0">{
                if m.Status != domain.MatchStatusPlayed </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">home := standingMap[m.HomeTeamID]
                away := standingMap[m.AwayTeamID]

                // Safety check if team was deleted but match exists
                if home == nil || away == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">home.Played++
                away.Played++
                home.GoalsFor += m.ScoreHome
                home.GoalsAgainst += m.ScoreAway
                away.GoalsFor += m.ScoreAway
                away.GoalsAgainst += m.ScoreHome

                if m.ScoreHome &gt; m.ScoreAway </span><span class="cov0" title="0">{
                        home.Won++
                        home.Points += 3
                        away.Lost++
                }</span> else<span class="cov0" title="0"> if m.ScoreAway &gt; m.ScoreHome </span><span class="cov0" title="0">{
                        away.Won++
                        away.Points += 3
                        home.Lost++
                }</span> else<span class="cov0" title="0"> {
                        home.Drawn++
                        home.Points += 1
                        away.Drawn++
                        away.Points += 1
                }</span>
        }

        // 4. Convert map to slice
        <span class="cov0" title="0">var standings []domain.Standing
        for _, s := range standingMap </span><span class="cov0" title="0">{
                standings = append(standings, *s)
        }</span>

        // Sort by points (desc), then goal diff? For MVP just return list. UseCase can sort.
        <span class="cov0" title="0">return standings, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package repository

import (
        "errors"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/disciplines/domain"
        "gorm.io/gorm"
)

type PostgresDisciplineRepository struct {
        db *gorm.DB
}

func NewPostgresDisciplineRepository(db *gorm.DB) *PostgresDisciplineRepository <span class="cov0" title="0">{
        return &amp;PostgresDisciplineRepository{db: db}
}</span>

func (r *PostgresDisciplineRepository) CreateDiscipline(discipline *domain.Discipline) error <span class="cov0" title="0">{
        return r.db.Create(discipline).Error
}</span>

func (r *PostgresDisciplineRepository) ListDisciplines(clubID string) ([]domain.Discipline, error) <span class="cov0" title="0">{
        var disciplines []domain.Discipline
        err := r.db.Where("is_active = ? AND club_id = ?", true, clubID).Find(&amp;disciplines).Error
        return disciplines, err
}</span>

func (r *PostgresDisciplineRepository) GetDisciplineByID(clubID string, id uuid.UUID) (*domain.Discipline, error) <span class="cov0" title="0">{
        var discipline domain.Discipline
        if err := r.db.First(&amp;discipline, "id = ? AND club_id = ?", id, clubID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;discipline, nil</span>
}

func (r *PostgresDisciplineRepository) CreateGroup(group *domain.TrainingGroup) error <span class="cov0" title="0">{
        return r.db.Create(group).Error
}</span>

func (r *PostgresDisciplineRepository) ListGroups(clubID string, filter map[string]interface{}) ([]domain.TrainingGroup, error) <span class="cov0" title="0">{
        var groups []domain.TrainingGroup
        query := r.db.Preload("Discipline").Where("club_id = ?", clubID)
        if dID, ok := filter["discipline_id"]; ok </span><span class="cov0" title="0">{
                query = query.Where("discipline_id = ?", dID)
        }</span>
        <span class="cov0" title="0">if category, ok := filter["category"]; ok </span><span class="cov0" title="0">{
                query = query.Where("category = ?", category)
        }</span>
        <span class="cov0" title="0">err := query.Find(&amp;groups).Error
        return groups, err</span>
}

func (r *PostgresDisciplineRepository) GetGroupByID(clubID string, id uuid.UUID) (*domain.TrainingGroup, error) <span class="cov0" title="0">{
        var group domain.TrainingGroup
        if err := r.db.Preload("Discipline").First(&amp;group, "id = ? AND club_id = ?", id, clubID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;group, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package application

import (
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/domain"
        "github.com/lukcba/club-pulse-system-api/backend/internal/platform/embedding"
)

// SemanticSearchResult represents a search result with similarity score
type SemanticSearchResult struct {
        Facility   *domain.Facility `json:"facility"`
        Similarity float32          `json:"similarity"`
}

// SemanticSearchUseCase handles semantic search for facilities
type SemanticSearchUseCase struct {
        repo     domain.FacilityRepository
        embedder *embedding.EmbeddingService
}

// NewSemanticSearchUseCase creates a new semantic search use case
func NewSemanticSearchUseCase(repo domain.FacilityRepository) *SemanticSearchUseCase <span class="cov0" title="0">{
        return &amp;SemanticSearchUseCase{
                repo:     repo,
                embedder: embedding.NewEmbeddingService(),
        }
}</span>

// Search performs a semantic search for facilities matching the query
// Example queries: "canchas techadas para lluvia", "piscina climatizada", "tenis noche"
func (uc *SemanticSearchUseCase) Search(clubID, query string, limit int) ([]*SemanticSearchResult, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        // Generate embedding for query
        <span class="cov0" title="0">queryEmbedding := uc.embedder.GenerateEmbedding(query)

        // Search in database using pgvector
        results, err := uc.repo.SemanticSearch(clubID, queryEmbedding, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to response format
        <span class="cov0" title="0">searchResults := make([]*SemanticSearchResult, len(results))
        for i, r := range results </span><span class="cov0" title="0">{
                searchResults[i] = &amp;SemanticSearchResult{
                        Facility:   r.Facility,
                        Similarity: r.Similarity,
                }
        }</span>

        <span class="cov0" title="0">return searchResults, nil</span>
}

// GenerateAndStoreEmbedding generates an embedding for a facility and stores it
func (uc *SemanticSearchUseCase) GenerateAndStoreEmbedding(facility *domain.Facility) error <span class="cov0" title="0">{
        // Build text from facility data for embedding
        text := buildFacilityText(facility)

        // Generate embedding
        emb := uc.embedder.GenerateEmbedding(text)

        // Store in database
        return uc.repo.UpdateEmbedding(facility.ID, emb)
}</span>

// GenerateAllEmbeddings generates embeddings for all facilities (batch operation)
func (uc *SemanticSearchUseCase) GenerateAllEmbeddings(clubID string) (int, error) <span class="cov0" title="0">{
        facilities, err := uc.repo.List(clubID, 1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">count := 0
        for _, fac := range facilities </span><span class="cov0" title="0">{
                if err := uc.GenerateAndStoreEmbedding(fac); err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with other facilities
                        continue</span>
                }
                <span class="cov0" title="0">count++</span>
        }

        <span class="cov0" title="0">return count, nil</span>
}

// buildFacilityText creates a searchable text representation of a facility
func buildFacilityText(f *domain.Facility) string <span class="cov0" title="0">{
        text := f.Name + " "
        text += string(f.Type) + " "

        // Add specifications
        if f.Specifications.SurfaceType != nil </span><span class="cov0" title="0">{
                text += *f.Specifications.SurfaceType + " "
        }</span>
        <span class="cov0" title="0">if f.Specifications.Lighting </span><span class="cov0" title="0">{
                text += "iluminacion nocturno noche "
        }</span>
        <span class="cov0" title="0">if f.Specifications.Covered </span><span class="cov0" title="0">{
                text += "techado cubierto lluvia "
        }</span>
        <span class="cov0" title="0">for _, eq := range f.Specifications.Equipment </span><span class="cov0" title="0">{
                text += eq + " "
        }</span>

        // Add location
        <span class="cov0" title="0">text += f.Location.Name + " "
        text += f.Location.Description

        return text</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package application

import (
        "errors"
        "time"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/domain"
)

type FacilityUseCases struct {
        repo domain.FacilityRepository
}

func NewFacilityUseCases(repo domain.FacilityRepository) *FacilityUseCases <span class="cov0" title="0">{
        return &amp;FacilityUseCases{
                repo: repo,
        }
}</span>

type CreateFacilityDTO struct {
        Name           string                `json:"name" binding:"required"`
        Type           domain.FacilityType   `json:"type" binding:"required"`
        Capacity       int                   `json:"capacity" binding:"required,min=1"`
        HourlyRate     float64               `json:"hourly_rate" binding:"required,min=0"`
        Specifications domain.Specifications `json:"specifications"`
        Location       domain.Location       `json:"location"`
}

func (uc *FacilityUseCases) CreateFacility(clubID string, dto CreateFacilityDTO) (*domain.Facility, error) <span class="cov0" title="0">{
        facility := &amp;domain.Facility{
                ID:             uuid.New().String(),
                ClubID:         clubID,
                Name:           dto.Name,
                Type:           dto.Type,
                Status:         domain.FacilityStatusActive,
                Capacity:       dto.Capacity,
                HourlyRate:     dto.HourlyRate,
                Specifications: dto.Specifications,
                Location:       dto.Location,
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }

        if err := uc.repo.Create(facility); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return facility, nil</span>
}

func (uc *FacilityUseCases) ListFacilities(clubID string, limit, offset int) ([]*domain.Facility, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>
        <span class="cov0" title="0">return uc.repo.List(clubID, limit, offset)</span>
}

func (uc *FacilityUseCases) GetFacility(clubID, id string) (*domain.Facility, error) <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, errors.New("invalid ID")
        }</span>
        <span class="cov0" title="0">return uc.repo.GetByID(clubID, id)</span>
}

type UpdateFacilityDTO struct {
        Name           *string                `json:"name,omitempty"`
        Status         *domain.FacilityStatus `json:"status,omitempty"`
        Specifications *domain.Specifications `json:"specifications,omitempty"`
}

func (uc *FacilityUseCases) UpdateFacility(clubID, id string, dto UpdateFacilityDTO) (*domain.Facility, error) <span class="cov0" title="0">{
        facility, err := uc.repo.GetByID(clubID, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if facility == nil </span><span class="cov0" title="0">{
                return nil, errors.New("facility not found")
        }</span>

        <span class="cov0" title="0">if dto.Name != nil </span><span class="cov0" title="0">{
                facility.Name = *dto.Name
        }</span>
        <span class="cov0" title="0">if dto.Status != nil </span><span class="cov0" title="0">{
                facility.Status = *dto.Status
        }</span>
        <span class="cov0" title="0">if dto.Specifications != nil </span><span class="cov0" title="0">{
                // Full replacement of specs for simplicity in MVP, or merge?
                // Let's do partial update if needed, but struct replacement is easier for now.
                // Actually, since specifications is a struct, we should probably merge if we want specific fields,
                // but given the DTO has a pointer to the full struct, we replace it.
                // Ideally we'd have meaningful merge logic, but MVP: replace.
                facility.Specifications = *dto.Specifications
        }</span>

        <span class="cov0" title="0">if err := uc.repo.Update(facility); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return facility, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package domain

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "time"
)

// Enums

type FacilityType string

const (
        FacilityTypeCourt FacilityType = "court"
        FacilityTypePool  FacilityType = "pool"
        FacilityTypeGym   FacilityType = "gym"
        FacilityTypeField FacilityType = "field"
)

type FacilityStatus string

const (
        FacilityStatusActive      FacilityStatus = "active"
        FacilityStatusMaintenance FacilityStatus = "maintenance"
        FacilityStatusClosed      FacilityStatus = "closed"
)

// JSONB Structures

type Specifications struct {
        SurfaceType *string  `json:"surface_type,omitempty"`
        Lighting    bool     `json:"lighting"`
        Covered     bool     `json:"covered"`
        Equipment   []string `json:"equipment,omitempty"` // Basic inventory list
}

// Value method for GORM storage
func (s Specifications) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(s)
}</span>

// Scan method for GORM storage
func (s *Specifications) Scan(value interface{}) error <span class="cov0" title="0">{
        b, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("type assertion to []byte failed")
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(b, s)</span>
}

type Location struct {
        Name        string `json:"name"` // e.g. "Main Building"
        Description string `json:"description,omitempty"`
}

func (l Location) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(l)
}</span>

func (l *Location) Scan(value interface{}) error <span class="cov0" title="0">{
        b, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("type assertion to []byte failed")
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(b, l)</span>
}

// Main Entity

type Facility struct {
        ID             string         `json:"id"`
        ClubID         string         `json:"club_id" gorm:"index;not null"`
        Name           string         `json:"name"`
        Type           FacilityType   `json:"type"`
        Status         FacilityStatus `json:"status"`
        Capacity       int            `json:"capacity"`
        HourlyRate     float64        `json:"hourly_rate"`
        Specifications Specifications `json:"specifications"` // Stored as JSONB
        Location       Location       `json:"location"`       // Stored as JSONB

        // Semantic Search (pgvector)
        Embedding []float32 `json:"-" gorm:"-"` // Managed by 002_pgvector_indexes.sql

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// FacilityWithSimilarity represents a facility with its search similarity score
type FacilityWithSimilarity struct {
        Facility   *Facility
        Similarity float32
}

// Repository Interface

type FacilityRepository interface {
        Create(facility *Facility) error
        GetByID(clubID, id string) (*Facility, error)
        List(clubID string, limit, offset int) ([]*Facility, error)
        Update(facility *Facility) error

        // Maintenance Extensions
        HasConflict(clubID, facilityID string, startTime, endTime time.Time) (bool, error)

        // Semantic Search Extensions
        SemanticSearch(clubID string, embedding []float32, limit int) ([]*FacilityWithSimilarity, error)
        UpdateEmbedding(facilityID string, embedding []float32) error
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package http

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/application"
)

type FacilityHandler struct {
        useCases *application.FacilityUseCases
}

func NewFacilityHandler(useCases *application.FacilityUseCases) *FacilityHandler <span class="cov0" title="0">{
        return &amp;FacilityHandler{
                useCases: useCases,
        }
}</span>

func RegisterRoutes(r *gin.RouterGroup, handler *FacilityHandler, authMiddleware, tenantMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        facilities := r.Group("/facilities")
        // Public routes? Or protected? Let's protect create, allow public read potentially.
        // For MVP, protect all write ops.

        protected := facilities.Group("")
        protected.Use(authMiddleware, tenantMiddleware)
        </span><span class="cov0" title="0">{
                protected.GET("", handler.List)
                protected.GET("/:id", handler.Get)
                protected.POST("", handler.Create)
                protected.PUT("/:id", handler.Update)
        }</span>
}

func (h *FacilityHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var dto application.CreateFacilityDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        facility, err := h.useCases.CreateFacility(clubID, dto)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, facility)</span>
}

// List godoc
// @Summary      List facilities
// @Description  Get a list of facilities for the authenticated club
// @Tags         facilities
// @Accept       json
// @Produce      json
// @Param        limit   query      int  false  "Limit"
// @Param        offset  query      int  false  "Offset"
// @Success      200     {array}    domain.Facility
// @Failure      500     {object}   map[string]string
// @Router       /facilities [get]
func (h *FacilityHandler) List(c *gin.Context) <span class="cov0" title="0">{
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        clubID := c.GetString("clubID")

        facilities, err := h.useCases.ListFacilities(clubID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, facilities)</span>
}

func (h *FacilityHandler) Get(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        clubID := c.GetString("clubID")
        facility, err := h.useCases.GetFacility(clubID, id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">if facility == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Facility not found"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, facility)</span>
}

func (h *FacilityHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        var dto application.UpdateFacilityDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        facility, err := h.useCases.UpdateFacility(clubID, id, dto)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, facility)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package http

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/application"
)

// SearchHandler handles semantic search for facilities
type SearchHandler struct {
        searchUseCase *application.SemanticSearchUseCase
}

// NewSearchHandler creates a new search handler
func NewSearchHandler(searchUseCase *application.SemanticSearchUseCase) *SearchHandler <span class="cov0" title="0">{
        return &amp;SearchHandler{
                searchUseCase: searchUseCase,
        }
}</span>

// RegisterSearchRoutes registers the semantic search routes
func RegisterSearchRoutes(r *gin.RouterGroup, handler *SearchHandler) <span class="cov0" title="0">{
        facilities := r.Group("/facilities")
        </span><span class="cov0" title="0">{
                // GET /api/v1/facilities/search?q=canchas+techadas&amp;limit=10
                facilities.GET("/search", handler.Search)

                // POST /api/v1/facilities/embeddings/generate - Admin only, generates embeddings for all facilities
                facilities.POST("/embeddings/generate", handler.GenerateEmbeddings)
        }</span>
}

// Search performs semantic search on facilities
// @Summary Search facilities using natural language
// @Description Search for facilities using semantic similarity (e.g., "canchas para lluvia", "piscina nocturna")
// @Tags Facilities
// @Produce json
// @Param q query string true "Search query in natural language"
// @Param limit query int false "Maximum results (default 10)"
// @Success 200 {array} application.SemanticSearchResult
// @Router /facilities/search [get]
func (h *SearchHandler) Search(c *gin.Context) <span class="cov0" title="0">{
        query := c.Query("q")
        if query == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Missing search query",
                        "message": "Please provide a search query using the 'q' parameter",
                        "example": "/facilities/search?q=canchas+techadas+para+lluvia",
                })
                return
        }</span>

        <span class="cov0" title="0">limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))
        if limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        results, err := h.searchUseCase.Search(clubID, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Search failed",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "query":   query,
                "count":   len(results),
                "results": results,
        })</span>
}

// GenerateEmbeddings generates embeddings for all facilities (admin operation)
// @Summary Generate embeddings for all facilities
// @Description Batch operation to generate and store embeddings for all facilities
// @Tags Facilities
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Router /facilities/embeddings/generate [post]
func (h *SearchHandler) GenerateEmbeddings(c *gin.Context) <span class="cov0" title="0">{
        clubID := c.GetString("clubID")
        count, err := h.searchUseCase.GenerateAllEmbeddings(clubID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to generate embeddings",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message":   "Embeddings generated successfully",
                "processed": count,
        })</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package repository

import (
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/facilities/domain"
        "gorm.io/gorm"
)

type PostgresFacilityRepository struct {
        db *gorm.DB
}

func NewPostgresFacilityRepository(db *gorm.DB) *PostgresFacilityRepository <span class="cov0" title="0">{
        log.Println("DEBUG: Running AutoMigrate for Facilities...")
        err := db.AutoMigrate(&amp;FacilityModel{}, &amp;MaintenanceTaskModel{}, &amp;EquipmentModel{})
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: AutoMigrate Failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Println("DEBUG: AutoMigrate Success")
        }</span>
        <span class="cov0" title="0">return &amp;PostgresFacilityRepository{db: db}</span>
}

// FacilityModel mirrors domain.Facility but with GORM tags
type FacilityModel struct {
        ID             string                `gorm:"primaryKey"`
        Name           string                `gorm:"not null"`
        Type           string                `gorm:"not null"`
        Status         string                `gorm:"default:'active'"`
        Capacity       int                   `gorm:"not null"`
        HourlyRate     float64               `gorm:"not null"`
        Specifications domain.Specifications `gorm:"type:jsonb;serializer:json"` // Postgres JSONB
        Location       domain.Location       `gorm:"type:jsonb;serializer:json"`
        ClubID         string                `gorm:"index;not null"`
        CreatedAt      time.Time
        UpdatedAt      time.Time
}

func (FacilityModel) TableName() string <span class="cov0" title="0">{
        return "facilities"
}</span>

func (r *PostgresFacilityRepository) Create(facility *domain.Facility) error <span class="cov0" title="0">{
        model := FacilityModel{
                ID:             facility.ID,
                Name:           facility.Name,
                Type:           string(facility.Type),
                Status:         string(facility.Status),
                Capacity:       facility.Capacity,
                HourlyRate:     facility.HourlyRate,
                Specifications: facility.Specifications,
                Location:       facility.Location,
                ClubID:         facility.ClubID,
                CreatedAt:      facility.CreatedAt,
                UpdatedAt:      facility.UpdatedAt,
        }
        return r.db.Create(&amp;model).Error
}</span>

func (r *PostgresFacilityRepository) GetByID(clubID, id string) (*domain.Facility, error) <span class="cov0" title="0">{
        var model FacilityModel
        result := r.db.Where("id = ? AND club_id = ?", id, clubID).First(&amp;model)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }
        <span class="cov0" title="0">return r.toDomain(model), nil</span>
}

func (r *PostgresFacilityRepository) List(clubID string, limit, offset int) ([]*domain.Facility, error) <span class="cov0" title="0">{
        var models []FacilityModel
        result := r.db.Where("club_id = ?", clubID).Limit(limit).Offset(offset).Find(&amp;models)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">facilities := make([]*domain.Facility, len(models))
        for i, m := range models </span><span class="cov0" title="0">{
                facilities[i] = r.toDomain(m)
        }</span>
        <span class="cov0" title="0">return facilities, nil</span>
}

func (r *PostgresFacilityRepository) Update(facility *domain.Facility) error <span class="cov0" title="0">{
        model := FacilityModel{
                ID:             facility.ID,
                Name:           facility.Name,
                Type:           string(facility.Type),
                Status:         string(facility.Status),
                Capacity:       facility.Capacity,
                HourlyRate:     facility.HourlyRate,
                Specifications: facility.Specifications,
                Location:       facility.Location,
                CreatedAt:      facility.CreatedAt,
                UpdatedAt:      time.Now(), // Update timestamp
        }
        // Save updates all fields (including zero values) which is what we want for struct replacement
        return r.db.Save(&amp;model).Error
}</span>

func (r *PostgresFacilityRepository) toDomain(m FacilityModel) *domain.Facility <span class="cov0" title="0">{
        return &amp;domain.Facility{
                ID:             m.ID,
                Name:           m.Name,
                Type:           domain.FacilityType(m.Type),
                Status:         domain.FacilityStatus(m.Status),
                Capacity:       m.Capacity,
                HourlyRate:     m.HourlyRate,
                Specifications: m.Specifications,
                Location:       m.Location,
                ClubID:         m.ClubID,
                CreatedAt:      m.CreatedAt,
                UpdatedAt:      m.UpdatedAt,
        }
}</span>

// Maintenance Logic

type MaintenanceTaskModel struct {
        ID          string    `gorm:"primaryKey"`
        FacilityID  string    `gorm:"not null;index"`
        EquipmentID *string   `gorm:"index"`
        Title       string    `gorm:"not null"`
        Description string    `gorm:"type:text"`
        Status      string    `gorm:"not null"`
        Type        string    `gorm:"not null"`
        StartTime   time.Time `gorm:"not null;index"`
        EndTime     time.Time `gorm:"not null;index"`
        CreatedBy   string
        CreatedAt   time.Time
        UpdatedAt   time.Time
}

func (MaintenanceTaskModel) TableName() string <span class="cov0" title="0">{
        return "maintenance_tasks"
}</span>

type EquipmentModel struct {
        ID           string `gorm:"primaryKey"`
        FacilityID   string `gorm:"not null;index"`
        Name         string `gorm:"not null"`
        Type         string `gorm:"not null"`
        Condition    string `gorm:"not null"`
        Status       string `gorm:"not null"`
        PurchaseDate *time.Time
        CreatedAt    time.Time
        UpdatedAt    time.Time
}

func (EquipmentModel) TableName() string <span class="cov0" title="0">{
        return "equipment"
}</span>

// Implement MaintenanceRepository

func (r *PostgresFacilityRepository) AutoMigrateMaintenance() error <span class="cov0" title="0">{
        return r.db.AutoMigrate(&amp;MaintenanceTaskModel{}, &amp;EquipmentModel{})
}</span>

func (r *PostgresFacilityRepository) CreateMaintenance(task *domain.MaintenanceTask) error <span class="cov0" title="0">{
        model := MaintenanceTaskModel{
                ID:          task.ID,
                FacilityID:  task.FacilityID,
                EquipmentID: task.EquipmentID,
                Title:       task.Title,
                Description: task.Description,
                Status:      string(task.Status),
                Type:        string(task.Type),
                StartTime:   task.StartTime,
                EndTime:     task.EndTime,
                CreatedBy:   task.CreatedBy,
                CreatedAt:   task.CreatedAt,
                UpdatedAt:   task.UpdatedAt,
        }
        return r.db.Create(&amp;model).Error
}</span>

func (r *PostgresFacilityRepository) GetMaintenanceByID(id string) (*domain.MaintenanceTask, error) <span class="cov0" title="0">{
        var model MaintenanceTaskModel
        if err := r.db.First(&amp;model, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;domain.MaintenanceTask{
                ID:          model.ID,
                FacilityID:  model.FacilityID,
                EquipmentID: model.EquipmentID,
                Title:       model.Title,
                Description: model.Description,
                Status:      domain.MaintenanceStatus(model.Status),
                Type:        domain.MaintenanceType(model.Type),
                StartTime:   model.StartTime,
                EndTime:     model.EndTime,
                CreatedBy:   model.CreatedBy,
                CreatedAt:   model.CreatedAt,
                UpdatedAt:   model.UpdatedAt,
        }, nil</span>
}

func (r *PostgresFacilityRepository) ListMaintenanceByFacility(facilityID string) ([]*domain.MaintenanceTask, error) <span class="cov0" title="0">{
        var models []MaintenanceTaskModel
        if err := r.db.Where("facility_id = ?", facilityID).Find(&amp;models).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tasks := make([]*domain.MaintenanceTask, len(models))
        for i, m := range models </span><span class="cov0" title="0">{
                tasks[i] = &amp;domain.MaintenanceTask{
                        ID:          m.ID,
                        FacilityID:  m.FacilityID,
                        EquipmentID: m.EquipmentID,
                        Title:       m.Title,
                        Description: m.Description,
                        Status:      domain.MaintenanceStatus(m.Status),
                        Type:        domain.MaintenanceType(m.Type),
                        StartTime:   m.StartTime,
                        EndTime:     m.EndTime,
                        CreatedBy:   m.CreatedBy,
                        CreatedAt:   m.CreatedAt,
                        UpdatedAt:   m.UpdatedAt,
                }
        }</span>
        <span class="cov0" title="0">return tasks, nil</span>
}

func (r *PostgresFacilityRepository) HasConflict(clubID, facilityID string, startTime, endTime time.Time) (bool, error) <span class="cov0" title="0">{
        var count int64
        // Check for any maintenance task that overlaps and is active.
        // Tasks are linked to facility. We trust facilityID matches clubID via previous lookups or join if strictly necessary.
        // But maintenance tasks don't have ClubID on them explicitly, they rely on FacilityID.
        // So just filtering by FacilityID is technically enough if we trust the facilityID belongs to the club.
        // However, for strictness, we could join or check facility. But keeping it simple as Facility ownership is verified by ID.
        err := r.db.Model(&amp;MaintenanceTaskModel{}).
                Where("facility_id = ?", facilityID).
                Where("status IN ?", []string{string(domain.MaintenanceStatusScheduled), string(domain.MaintenanceStatusInProgress)}).
                Where("start_time &lt; ? AND end_time &gt; ?", endTime, startTime).
                Count(&amp;count).Error

        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// Implement EquipmentRepository

func (r *PostgresFacilityRepository) CreateEquipment(equipment *domain.Equipment) error <span class="cov0" title="0">{
        model := EquipmentModel{
                ID:           equipment.ID,
                FacilityID:   equipment.FacilityID,
                Name:         equipment.Name,
                Type:         equipment.Type,
                Condition:    string(equipment.Condition),
                Status:       equipment.Status,
                PurchaseDate: equipment.PurchaseDate,
                CreatedAt:    equipment.CreatedAt,
                UpdatedAt:    equipment.UpdatedAt,
        }
        return r.db.Create(&amp;model).Error
}</span>

func (r *PostgresFacilityRepository) GetEquipmentByID(id string) (*domain.Equipment, error) <span class="cov0" title="0">{
        var model EquipmentModel
        if err := r.db.First(&amp;model, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return r.toDomainEquipment(model), nil</span>
}

func (r *PostgresFacilityRepository) ListEquipmentByFacility(facilityID string) ([]*domain.Equipment, error) <span class="cov0" title="0">{
        var models []EquipmentModel
        if err := r.db.Where("facility_id = ?", facilityID).Find(&amp;models).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">equipments := make([]*domain.Equipment, len(models))
        for i, m := range models </span><span class="cov0" title="0">{
                equipments[i] = r.toDomainEquipment(m)
        }</span>
        <span class="cov0" title="0">return equipments, nil</span>
}

func (r *PostgresFacilityRepository) UpdateEquipment(equipment *domain.Equipment) error <span class="cov0" title="0">{
        model := EquipmentModel{
                ID:           equipment.ID,
                FacilityID:   equipment.FacilityID,
                Name:         equipment.Name,
                Type:         equipment.Type,
                Condition:    string(equipment.Condition),
                Status:       equipment.Status,
                PurchaseDate: equipment.PurchaseDate,
                CreatedAt:    equipment.CreatedAt,
                UpdatedAt:    time.Now(),
        }
        return r.db.Save(&amp;model).Error
}</span>

func (r *PostgresFacilityRepository) toDomainEquipment(m EquipmentModel) *domain.Equipment <span class="cov0" title="0">{
        return &amp;domain.Equipment{
                ID:           m.ID,
                FacilityID:   m.FacilityID,
                Name:         m.Name,
                Type:         m.Type,
                Condition:    domain.EquipmentCondition(m.Condition),
                Status:       m.Status,
                PurchaseDate: m.PurchaseDate,
                CreatedAt:    m.CreatedAt,
                UpdatedAt:    m.UpdatedAt,
        }
}</span>

// SemanticSearch performs vector similarity search using pgvector
func (r *PostgresFacilityRepository) SemanticSearch(clubID string, embedding []float32, limit int) ([]*domain.FacilityWithSimilarity, error) <span class="cov0" title="0">{
        // Convert embedding to PostgreSQL vector format
        vectorStr := float32SliceToVectorString(embedding)

        // Query using pgvector cosine distance operator &lt;=&gt;
        query := `
                SELECT 
                        id, name, type, status, capacity, hourly_rate, 
                        specifications, location, created_at, updated_at, club_id,
                        1 - (embedding &lt;=&gt; $1::vector) as similarity
                FROM facilities 
                WHERE embedding IS NOT NULL AND status = 'active' AND club_id = $3
                ORDER BY embedding &lt;=&gt; $1::vector
                LIMIT $2
        `

        rows, err := r.db.Raw(query, vectorStr, limit, clubID).Rows()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []*domain.FacilityWithSimilarity
        for rows.Next() </span><span class="cov0" title="0">{
                var m FacilityModel
                var similarity float32

                if err := rows.Scan(
                        &amp;m.ID, &amp;m.Name, &amp;m.Type, &amp;m.Status, &amp;m.Capacity, &amp;m.HourlyRate,
                        &amp;m.Specifications, &amp;m.Location, &amp;m.CreatedAt, &amp;m.UpdatedAt, &amp;m.ClubID,
                        &amp;similarity,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">results = append(results, &amp;domain.FacilityWithSimilarity{
                        Facility:   r.toDomain(m),
                        Similarity: similarity,
                })</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// UpdateEmbedding stores the embedding vector for a facility
func (r *PostgresFacilityRepository) UpdateEmbedding(facilityID string, embedding []float32) error <span class="cov0" title="0">{
        vectorStr := float32SliceToVectorString(embedding)

        return r.db.Exec(
                "UPDATE facilities SET embedding = $1::vector WHERE id = $2",
                vectorStr, facilityID,
        ).Error
}</span>

// float32SliceToVectorString converts a []float32 to PostgreSQL vector string format [1.2,3.4,5.6]
func float32SliceToVectorString(v []float32) string <span class="cov0" title="0">{
        if len(v) == 0 </span><span class="cov0" title="0">{
                return "[]"
        }</span>

        <span class="cov0" title="0">result := "["
        for i, val := range v </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        result += ","
                }</span>
                <span class="cov0" title="0">result += fmt.Sprintf("%f", val)</span>
        }
        <span class="cov0" title="0">result += "]"
        return result</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package application

import (
        "context"
        "errors"
        "time"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/domain"
)

type CreateMembershipRequest struct {
        UserID           uuid.UUID           `json:"user_id" binding:"required"`
        MembershipTierID uuid.UUID           `json:"membership_tier_id" binding:"required"`
        BillingCycle     domain.BillingCycle `json:"billing_cycle" binding:"required"`
}

type MembershipUseCases struct {
        repo domain.MembershipRepository
}

func NewMembershipUseCases(repo domain.MembershipRepository) *MembershipUseCases <span class="cov0" title="0">{
        return &amp;MembershipUseCases{
                repo: repo,
        }
}</span>

func (uc *MembershipUseCases) ListTiers(ctx context.Context, clubID string) ([]domain.MembershipTier, error) <span class="cov0" title="0">{
        return uc.repo.ListTiers(ctx, clubID)
}</span>

func (uc *MembershipUseCases) CreateMembership(ctx context.Context, clubID string, req CreateMembershipRequest) (*domain.Membership, error) <span class="cov0" title="0">{
        // 1. Get Tier to calculate dates and validate
        tier, err := uc.repo.GetTierByID(ctx, clubID, req.MembershipTierID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid membership tier")
        }</span>

        // 2. Calculate dates
        <span class="cov0" title="0">now := time.Now()
        startDate := now
        var nextBilling time.Time

        switch req.BillingCycle </span>{
        case domain.BillingCycleMonthly:<span class="cov0" title="0">
                nextBilling = now.AddDate(0, 1, 0)</span>
        case domain.BillingCycleQuarterly:<span class="cov0" title="0">
                nextBilling = now.AddDate(0, 3, 0)</span>
        case domain.BillingCycleSemiAnnual:<span class="cov0" title="0">
                nextBilling = now.AddDate(0, 6, 0)</span>
        case domain.BillingCycleAnnual:<span class="cov0" title="0">
                nextBilling = now.AddDate(1, 0, 0)</span>
        default:<span class="cov0" title="0">
                nextBilling = now.AddDate(0, 1, 0)</span>
        }

        <span class="cov0" title="0">membership := &amp;domain.Membership{
                UserID:           req.UserID,
                MembershipTierID: req.MembershipTierID,
                MembershipTier:   *tier,
                ClubID:           clubID,
                Status:           domain.MembershipStatusActive, // Auto-activate for MVP
                BillingCycle:     req.BillingCycle,
                StartDate:        startDate,
                NextBillingDate:  nextBilling,
        }

        if err := uc.repo.Create(ctx, membership); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return membership, nil</span>
}

func (uc *MembershipUseCases) GetMembership(ctx context.Context, clubID string, id uuid.UUID) (*domain.Membership, error) <span class="cov0" title="0">{
        return uc.repo.GetByID(ctx, clubID, id)
}</span>

func (uc *MembershipUseCases) ListUserMemberships(ctx context.Context, clubID string, userID uuid.UUID) ([]domain.Membership, error) <span class="cov0" title="0">{
        return uc.repo.GetByUserID(ctx, clubID, userID)
}</span>

// ProcessMonthlyBilling runs the billing cycle for all active memberships
func (uc *MembershipUseCases) ProcessMonthlyBilling(ctx context.Context, clubID string) (int, error) <span class="cov0" title="0">{
        now := time.Now()
        billable, err := uc.repo.ListBillable(ctx, clubID, now)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">processedCount := 0
        for _, m := range billable </span><span class="cov0" title="0">{
                // Calculate new balance
                newBalance := m.OutstandingBalance.Add(m.MembershipTier.MonthlyFee)

                // Calculate next billing date (next month)
                nextBilling := m.NextBillingDate.AddDate(0, 1, 0)

                if err := uc.repo.UpdateBalance(ctx, clubID, m.ID, newBalance, nextBilling); err == nil </span><span class="cov0" title="0">{
                        processedCount++
                }</span>
        }

        <span class="cov0" title="0">return processedCount, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package domain

import (
        "context"
        "time"

        "github.com/google/uuid"
        "github.com/lib/pq"
        "github.com/shopspring/decimal"
        "gorm.io/gorm"
)

// Enums for Status and Cycle
type MembershipStatus string

const (
        MembershipStatusActive    MembershipStatus = "ACTIVE"
        MembershipStatusInactive  MembershipStatus = "INACTIVE"
        MembershipStatusPending   MembershipStatus = "PENDING"
        MembershipStatusCancelled MembershipStatus = "CANCELLED"
        MembershipStatusExpired   MembershipStatus = "EXPIRED"
)

type BillingCycle string

const (
        BillingCycleMonthly    BillingCycle = "MONTHLY"
        BillingCycleQuarterly  BillingCycle = "QUARTERLY"
        BillingCycleSemiAnnual BillingCycle = "SEMI_ANNUAL"
        BillingCycleAnnual     BillingCycle = "ANNUAL"
)

// MembershipTier defines the types of memberships available (Gold, Silver, etc.)
type MembershipTier struct {
        ID          uuid.UUID       `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        ClubID      string          `json:"club_id" gorm:"index;not null"`
        Name        string          `json:"name" gorm:"not null;size:255"`
        Description string          `json:"description" gorm:"type:text"`
        MonthlyFee  decimal.Decimal `json:"monthly_fee" gorm:"type:decimal(10,2);not null"`
        Colors      string          `json:"colors" gorm:"size:50"` // e.g. "bg-amber-100 text-amber-800" for frontend
        Benefits    pq.StringArray  `json:"benefits" gorm:"type:text[]"`
        IsActive    bool            `json:"is_active" gorm:"default:true"`

        CreatedAt time.Time      `json:"created_at" gorm:"autoCreateTime"`
        UpdatedAt time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
        DeletedAt gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`
}

// Membership represents a user's subscription
type Membership struct {
        ID               uuid.UUID      `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        ClubID           string         `json:"club_id" gorm:"index;not null"`
        UserID           uuid.UUID      `json:"user_id" gorm:"type:uuid;not null;index"`
        MembershipTierID uuid.UUID      `json:"membership_tier_id" gorm:"type:uuid;not null"`
        MembershipTier   MembershipTier `json:"membership_tier" gorm:"foreignKey:MembershipTierID"`

        Status       MembershipStatus `json:"status" gorm:"not null;default:'PENDING'"`
        BillingCycle BillingCycle     `json:"billing_cycle" gorm:"not null;default:'MONTHLY'"`

        StartDate          time.Time       `json:"start_date" gorm:"not null"`
        EndDate            *time.Time      `json:"end_date,omitempty"`
        NextBillingDate    time.Time       `json:"next_billing_date" gorm:"not null"`
        OutstandingBalance decimal.Decimal `json:"outstanding_balance" gorm:"type:decimal(10,2);default:0"`

        CreatedAt time.Time      `json:"created_at" gorm:"autoCreateTime"`
        UpdatedAt time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
        DeletedAt gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`
}

// CalculateLateFee determines if a late fee should be applied based on days past due
// Returns the fee amount (e.g., 10% of monthly fee)
func (m *Membership) CalculateLateFee() decimal.Decimal <span class="cov8" title="1">{
        now := time.Now()
        if now.Before(m.NextBillingDate) </span><span class="cov8" title="1">{
                return decimal.Zero
        }</span>

        // Example Logic: 10% penalty if overdue
        // In real app, this might be configurable per Tier
        <span class="cov8" title="1">return m.MembershipTier.MonthlyFee.Mul(decimal.NewFromFloat(0.10))</span>
}

// Repository Interface
type MembershipRepository interface {
        Create(ctx context.Context, membership *Membership) error
        GetByID(ctx context.Context, clubID string, id uuid.UUID) (*Membership, error)
        GetByUserID(ctx context.Context, clubID string, userID uuid.UUID) ([]Membership, error)
        ListTiers(ctx context.Context, clubID string) ([]MembershipTier, error)
        GetTierByID(ctx context.Context, clubID string, id uuid.UUID) (*MembershipTier, error)
        ListBillable(ctx context.Context, clubID string, date time.Time) ([]Membership, error)
        UpdateBalance(ctx context.Context, clubID string, membershipID uuid.UUID, newBalance decimal.Decimal, nextBilling time.Time) error
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package domain

import (
        "time"

        "github.com/google/uuid"
        "github.com/shopspring/decimal"
)

type SubscriptionStatus string

const (
        SubscriptionActive    SubscriptionStatus = "ACTIVE"
        SubscriptionPaused    SubscriptionStatus = "PAUSED"
        SubscriptionCancelled SubscriptionStatus = "CANCELLED"
        SubscriptionPastDue   SubscriptionStatus = "PAST_DUE" // Payment failed, retrying
)

// Subscription represents a recurring payment agreement for a membership.
type Subscription struct {
        ID              uuid.UUID          `json:"id"`
        UserID          string             `json:"user_id"`
        MembershipID    uuid.UUID          `json:"membership_id"`
        Amount          decimal.Decimal    `json:"amount"`
        Currency        string             `json:"currency"`
        Status          SubscriptionStatus `json:"status"`
        PaymentMethodID string             `json:"payment_method_id"` // Token or ID from Payment Provider (e.g., MP Card ID)
        NextBillingDate time.Time          `json:"next_billing_date"`
        LastPaymentDate *time.Time         `json:"last_payment_date,omitempty"`
        FailCount       int                `json:"fail_count"`
        CreatedAt       time.Time          `json:"created_at"`
        UpdatedAt       time.Time          `json:"updated_at"`
}

func NewSubscription(userID string, membershipID uuid.UUID, amount decimal.Decimal, paymentMethodID string) *Subscription <span class="cov0" title="0">{
        return &amp;Subscription{
                ID:              uuid.New(),
                UserID:          userID,
                MembershipID:    membershipID,
                Amount:          amount,
                Currency:        "ARS",
                Status:          SubscriptionActive,
                PaymentMethodID: paymentMethodID,
                NextBillingDate: time.Now().AddDate(0, 1, 0), // Default next month? detailed logic needed in service
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }
}</span>

type SubscriptionRepository interface {
        Create(subscription *Subscription) error
        GetByID(id uuid.UUID) (*Subscription, error)
        GetByUserID(userID string) ([]Subscription, error)
        Update(subscription *Subscription) error
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package http

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/application"
)

type MembershipHandler struct {
        useCases *application.MembershipUseCases
}

func NewMembershipHandler(useCases *application.MembershipUseCases) *MembershipHandler <span class="cov0" title="0">{
        return &amp;MembershipHandler{useCases: useCases}
}</span>

func RegisterRoutes(r *gin.RouterGroup, h *MembershipHandler, authMiddleware, tenantMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        memberships := r.Group("/memberships")
        memberships.Use(authMiddleware, tenantMiddleware)
        </span><span class="cov0" title="0">{
                memberships.POST("", h.CreateMembership)
                memberships.GET("", h.ListMemberships)
                memberships.GET("/tiers", h.ListTiers)
                memberships.GET("/:id", h.GetMembership)
                memberships.POST("/process-billing", h.ProcessBilling)
        }</span>
}

func (h *MembershipHandler) ListTiers(c *gin.Context) <span class="cov0" title="0">{
        clubID := c.GetString("clubID")
        tiers, err := h.useCases.ListTiers(c.Request.Context(), clubID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": tiers})</span>
}

func (h *MembershipHandler) CreateMembership(c *gin.Context) <span class="cov0" title="0">{
        var req application.CreateMembershipRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Override UserID from token if needed, or validate it matches
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>

        // Force UserID from token to ensure security
        <span class="cov0" title="0">req.UserID = uuid.MustParse(userID.(string))

        clubID := c.GetString("clubID")
        membership, err := h.useCases.CreateMembership(c.Request.Context(), clubID, req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{"data": membership})</span>
}

func (h *MembershipHandler) GetMembership(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid membership id"})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        membership, err := h.useCases.GetMembership(c.Request.Context(), clubID, id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": membership})</span>
}

func (h *MembershipHandler) ListMemberships(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">uid := uuid.MustParse(userID.(string))
        clubID := c.GetString("clubID")
        memberships, err := h.useCases.ListUserMemberships(c.Request.Context(), clubID, uid)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": memberships})</span>
}

func (h *MembershipHandler) ProcessBilling(c *gin.Context) <span class="cov0" title="0">{
        // In production, this would be restricted to ADMIN role.
        clubID := c.GetString("clubID")
        count, err := h.useCases.ProcessMonthlyBilling(c.Request.Context(), clubID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Billing cycle processed",
                "count":   count,
        })</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package repository

import (
        "context"
        "errors"
        "time"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/domain"
        "github.com/shopspring/decimal"
        "gorm.io/gorm"
)

type PostgresMembershipRepository struct {
        db *gorm.DB
}

func NewPostgresMembershipRepository(db *gorm.DB) *PostgresMembershipRepository <span class="cov0" title="0">{
        // AutoMigrate tables for MVP
        if err := db.AutoMigrate(&amp;domain.MembershipTier{}, &amp;domain.Membership{}); err != nil </span><span class="cov0" title="0">{
                // In a real app, we might panic or log fatal here, ensuring DB is consistent
                panic("failed to migrate membership tables: " + err.Error())</span>
        }
        <span class="cov0" title="0">return &amp;PostgresMembershipRepository{db: db}</span>
}

func (r *PostgresMembershipRepository) Create(ctx context.Context, membership *domain.Membership) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(membership).Error
}</span>

func (r *PostgresMembershipRepository) GetByID(ctx context.Context, clubID string, id uuid.UUID) (*domain.Membership, error) <span class="cov0" title="0">{
        var membership domain.Membership
        if err := r.db.WithContext(ctx).Preload("MembershipTier").First(&amp;membership, "id = ? AND club_id = ?", id, clubID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, errors.New("membership not found")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;membership, nil</span>
}

func (r *PostgresMembershipRepository) GetByUserID(ctx context.Context, clubID string, userID uuid.UUID) ([]domain.Membership, error) <span class="cov0" title="0">{
        var memberships []domain.Membership
        if err := r.db.WithContext(ctx).Preload("MembershipTier").Where("user_id = ? AND club_id = ?", userID, clubID).Find(&amp;memberships).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return memberships, nil</span>
}

func (r *PostgresMembershipRepository) ListTiers(ctx context.Context, clubID string) ([]domain.MembershipTier, error) <span class="cov0" title="0">{
        var tiers []domain.MembershipTier
        if err := r.db.WithContext(ctx).Where("is_active = ? AND club_id = ?", true, clubID).Order("monthly_fee asc").Find(&amp;tiers).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tiers, nil</span>
}

func (r *PostgresMembershipRepository) GetTierByID(ctx context.Context, clubID string, id uuid.UUID) (*domain.MembershipTier, error) <span class="cov0" title="0">{
        var tier domain.MembershipTier
        if err := r.db.WithContext(ctx).First(&amp;tier, "id = ? AND club_id = ?", id, clubID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, errors.New("membership tier not found")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;tier, nil</span>
}

func (r *PostgresMembershipRepository) ListBillable(ctx context.Context, clubID string, date time.Time) ([]domain.Membership, error) <span class="cov0" title="0">{
        var memberships []domain.Membership
        // Status Active AND NextBillingDate &lt;= today
        if err := r.db.WithContext(ctx).
                Preload("MembershipTier").
                Where("status = ? AND next_billing_date &lt;= ? AND club_id = ?", domain.MembershipStatusActive, date, clubID).
                Find(&amp;memberships).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return memberships, nil</span>
}

func (r *PostgresMembershipRepository) UpdateBalance(ctx context.Context, clubID string, membershipID uuid.UUID, newBalance decimal.Decimal, nextBilling time.Time) error <span class="cov0" title="0">{
        updates := map[string]interface{}{
                "outstanding_balance": newBalance,
                "next_billing_date":   nextBilling,
                "updated_at":          time.Now(),
        }
        return r.db.WithContext(ctx).Model(&amp;domain.Membership{}).Where("id = ? AND club_id = ?", membershipID, clubID).Updates(updates).Error
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package repository

import (
        "time"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/membership/domain"
        "github.com/shopspring/decimal"
        "gorm.io/gorm"
)

type PostgresSubscriptionRepository struct {
        db *gorm.DB
}

func NewPostgresSubscriptionRepository(db *gorm.DB) *PostgresSubscriptionRepository <span class="cov0" title="0">{
        return &amp;PostgresSubscriptionRepository{db: db}
}</span>

type SubscriptionModel struct {
        ID              uuid.UUID `gorm:"type:uuid;primary_key;default:uuid_generate_v4()"`
        UserID          string
        MembershipID    uuid.UUID
        Amount          decimal.Decimal `gorm:"type:decimal(10,2)"`
        Currency        string
        Status          string
        PaymentMethodID string
        NextBillingDate time.Time
        LastPaymentDate *time.Time
        FailCount       int
        CreatedAt       time.Time
        UpdatedAt       time.Time
        DeletedAt       gorm.DeletedAt `gorm:"index"`
}

func (SubscriptionModel) TableName() string <span class="cov0" title="0">{
        return "subscriptions"
}</span>

func (r *PostgresSubscriptionRepository) Create(subscription *domain.Subscription) error <span class="cov0" title="0">{
        model := r.toModel(subscription)
        return r.db.Create(model).Error
}</span>

func (r *PostgresSubscriptionRepository) GetByID(id uuid.UUID) (*domain.Subscription, error) <span class="cov0" title="0">{
        var model SubscriptionModel
        if err := r.db.First(&amp;model, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.toDomain(&amp;model), nil</span>
}

func (r *PostgresSubscriptionRepository) GetByUserID(userID string) ([]domain.Subscription, error) <span class="cov0" title="0">{
        var models []SubscriptionModel
        if err := r.db.Where("user_id = ?", userID).Find(&amp;models).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var subscriptions []domain.Subscription
        for _, m := range models </span><span class="cov0" title="0">{
                subscriptions = append(subscriptions, *r.toDomain(&amp;m))
        }</span>
        <span class="cov0" title="0">return subscriptions, nil</span>
}

func (r *PostgresSubscriptionRepository) Update(subscription *domain.Subscription) error <span class="cov0" title="0">{
        model := r.toModel(subscription)
        return r.db.Save(model).Error
}</span>

func (r *PostgresSubscriptionRepository) toModel(d *domain.Subscription) *SubscriptionModel <span class="cov0" title="0">{
        return &amp;SubscriptionModel{
                ID:              d.ID,
                UserID:          d.UserID,
                MembershipID:    d.MembershipID,
                Amount:          d.Amount,
                Currency:        d.Currency,
                Status:          string(d.Status),
                PaymentMethodID: d.PaymentMethodID,
                NextBillingDate: d.NextBillingDate,
                LastPaymentDate: d.LastPaymentDate,
                FailCount:       d.FailCount,
                CreatedAt:       d.CreatedAt,
                UpdatedAt:       d.UpdatedAt,
        }
}</span>

func (r *PostgresSubscriptionRepository) toDomain(m *SubscriptionModel) *domain.Subscription <span class="cov0" title="0">{
        return &amp;domain.Subscription{
                ID:              m.ID,
                UserID:          m.UserID,
                MembershipID:    m.MembershipID,
                Amount:          m.Amount,
                Currency:        m.Currency,
                Status:          domain.SubscriptionStatus(m.Status),
                PaymentMethodID: m.PaymentMethodID,
                NextBillingDate: m.NextBillingDate,
                LastPaymentDate: m.LastPaymentDate,
                FailCount:       m.FailCount,
                CreatedAt:       m.CreatedAt,
                UpdatedAt:       m.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package providers

import (
        "context"
        "errors"
        "fmt"
        "log"

        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/notification/service"
        "github.com/sendgrid/sendgrid-go"
        "github.com/sendgrid/sendgrid-go/helpers/mail"
)

type SendGridProvider struct {
        client    *sendgrid.Client
        fromName  string
        fromEmail string
}

func NewSendGridProvider(apiKey, fromName, fromEmail string) *SendGridProvider <span class="cov0" title="0">{
        return &amp;SendGridProvider{
                client:    sendgrid.NewSendClient(apiKey),
                fromName:  fromName,
                fromEmail: fromEmail,
        }
}</span>

func (p *SendGridProvider) SendEmail(ctx context.Context, to string, subject string, body string) (*service.DeliveryResult, error) <span class="cov0" title="0">{
        from := mail.NewEmail(p.fromName, p.fromEmail)
        toEmail := mail.NewEmail("", to)

        // Assuming body is plain text for simplicity, or we can treat as HTML
        message := mail.NewSingleEmail(from, subject, toEmail, body, body)

        resp, err := p.client.SendWithContext(ctx, message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("SendGrid Error: %v", err)
                return &amp;service.DeliveryResult{Success: false, ErrorMessage: err.Error()}, err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("SendGrid failed with status: %d, body: %s", resp.StatusCode, resp.Body)
                log.Println(errMsg)
                return &amp;service.DeliveryResult{Success: false, ErrorMessage: errMsg}, errors.New(errMsg)
        }</span>

        <span class="cov0" title="0">return &amp;service.DeliveryResult{
                Success:    true,
                ProviderID: resp.Headers["X-Message-Id"][0], // Helper access might need check
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package providers

import (
        "context"
        "log"

        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/notification/service"
        "github.com/twilio/twilio-go"
        openapi "github.com/twilio/twilio-go/rest/api/v2010"
)

type TwilioProvider struct {
        client     *twilio.RestClient
        fromNumber string
}

func NewTwilioProvider(accountSID, authToken, fromNumber string) *TwilioProvider <span class="cov0" title="0">{
        client := twilio.NewRestClientWithParams(twilio.ClientParams{
                Username: accountSID,
                Password: authToken,
        })
        return &amp;TwilioProvider{
                client:     client,
                fromNumber: fromNumber,
        }
}</span>

func (p *TwilioProvider) SendSMS(ctx context.Context, to string, message string) (*service.DeliveryResult, error) <span class="cov0" title="0">{
        params := &amp;openapi.CreateMessageParams{}
        params.SetTo(to)
        params.SetFrom(p.fromNumber)
        params.SetBody(message)

        resp, err := p.client.Api.CreateMessage(params)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Twilio Error: %v", err)
                return &amp;service.DeliveryResult{Success: false, ErrorMessage: err.Error()}, err
        }</span>

        <span class="cov0" title="0">return &amp;service.DeliveryResult{
                Success:    true,
                ProviderID: *resp.Sid,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package service

import (
        "context"
        "fmt"
)

type NotificationType string

const (
        NotificationTypeEmail NotificationType = "EMAIL"
        NotificationTypePush  NotificationType = "PUSH"
        NotificationTypeSMS   NotificationType = "SMS"
)

type Notification struct {
        RecipientID string
        Type        NotificationType
        Subject     string
        Message     string
}

type NotificationSender interface {
        Send(ctx context.Context, notification Notification) error
}

type NotificationService struct {
        emailProvider EmailProvider
        smsProvider   SMSProvider
}

func NewNotificationService(email EmailProvider, sms SMSProvider) *NotificationService <span class="cov0" title="0">{
        return &amp;NotificationService{
                emailProvider: email,
                smsProvider:   sms,
        }
}</span>

func (s *NotificationService) Send(ctx context.Context, n Notification) error <span class="cov0" title="0">{
        var err error

        switch n.Type </span>{
        case NotificationTypeEmail:<span class="cov0" title="0">
                if s.emailProvider != nil </span><span class="cov0" title="0">{
                        _, err = s.emailProvider.SendEmail(ctx, n.RecipientID, n.Subject, n.Message)
                }</span> else<span class="cov0" title="0"> {
                        // Fallback logging if provider not configured
                        fmt.Printf("[MOCK EMAIL] To: %s | Subject: %s\n", n.RecipientID, n.Subject)
                }</span>
        case NotificationTypePush:<span class="cov0" title="0">
                // Push not yet implemented, specific provider needed
                fmt.Printf("[MOCK PUSH] To: %s | Subject: %s\n", n.RecipientID, n.Subject)</span>
        case NotificationTypeSMS:<span class="cov0" title="0">
                // Assuming we add SMS type constant
                if s.smsProvider != nil </span><span class="cov0" title="0">{
                        _, err = s.smsProvider.SendSMS(ctx, n.RecipientID, n.Message)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("[MOCK SMS] To: %s | Body: %s\n", n.RecipientID, n.Message)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported notification type: %s", n.Type)</span>
        }

        <span class="cov0" title="0">return err</span>
}

// Deprecated: ConsoleMock kept for backward compat if needed temporarily
type ConsoleNotificationSender struct{}

func NewConsoleNotificationSender() *ConsoleNotificationSender <span class="cov0" title="0">{ return &amp;ConsoleNotificationSender{} }</span>
func (s *ConsoleNotificationSender) Send(ctx context.Context, n Notification) error <span class="cov0" title="0">{
        fmt.Printf("[CONSOLE FALLBACK] %s\n", n.Message)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package gateways

import (
        "context"
        "fmt"
        "time"

        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/domain"
)

// MockGateway is a mock implementation for testing
type MockGateway struct{}

func NewMockGateway() *MockGateway <span class="cov0" title="0">{
        return &amp;MockGateway{}
}</span>

func (p *MockGateway) CreatePreference(ctx context.Context, payment *domain.Payment, payerEmail string, description string) (string, error) <span class="cov0" title="0">{
        // For mock, simply return a fake checkout URL with the Payment ID
        mockURL := fmt.Sprintf("https://www.mercadopago.com.ar/checkout/v1/redirect?pref_id=mock-%s", payment.ID.String())
        return mockURL, nil
}</span>

func (p *MockGateway) ProcessWebhook(ctx context.Context, payload interface{}) (*domain.Payment, error) <span class="cov0" title="0">{
        // Simulate parsing a webhook payload and returning the updated payment status
        now := time.Now()
        // In a real Mock, we might inspect payload to decide success/fail
        return &amp;domain.Payment{
                // ID would be matched from ExternalReference in payload ideally,
                // but here we just return a stub to be updated.
                // Logic in handler handles retrieval by ID usually.
                Status: domain.PaymentStatusCompleted,
                Method: domain.PaymentMethodMercadoPago,
                PaidAt: &amp;now,
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package gateways

import (
        "context"
        "fmt"
        "os"
        "strconv"
        "time"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/domain"
        "github.com/mercadopago/sdk-go/pkg/config"
        mp_payment "github.com/mercadopago/sdk-go/pkg/payment"
        "github.com/mercadopago/sdk-go/pkg/preference"
)

type MercadoPagoGateway struct {
        accessToken string
}

func NewMercadoPagoGateway() *MercadoPagoGateway <span class="cov0" title="0">{
        token := os.Getenv("MP_ACCESS_TOKEN")
        if token == "" </span><span class="cov0" title="0">{
                // Fallback for dev/test if not set, though SDK might complain
                token = "TEST-ACCESS-TOKEN-PLACEHOLDER"
        }</span>
        <span class="cov0" title="0">return &amp;MercadoPagoGateway{
                accessToken: token,
        }</span>
}

func (g *MercadoPagoGateway) CreatePreference(ctx context.Context, payment *domain.Payment, payerEmail string, description string) (string, error) <span class="cov0" title="0">{
        cfg, err := config.New(g.accessToken)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create payment config: %w", err)
        }</span>

        <span class="cov0" title="0">client := preference.NewClient(cfg)

        // Amount conversion (Decimal to Float64)
        amount, _ := payment.Amount.Float64()

        request := preference.Request{
                Items: []preference.ItemRequest{
                        {
                                Title:       description,
                                Quantity:    1,
                                UnitPrice:   amount,
                                CurrencyID:  payment.Currency,
                                Description: description,
                        },
                },
                Payer: &amp;preference.PayerRequest{
                        Email: payerEmail,
                },
                BackURLs: &amp;preference.BackURLsRequest{
                        Success: "http://localhost:3000/payment/result?status=success",
                        Failure: "http://localhost:3000/payment/result?status=failure",
                        Pending: "http://localhost:3000/payment/result?status=pending",
                },
                AutoReturn:        "approved",
                ExternalReference: payment.ID.String(),
                NotificationURL:   "https://your-domain.ngrok.io/api/v1/payments/webhook", // Placeholder for local dev
        }

        resp, err := client.Create(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error creating preference: %w", err)
        }</span>

        <span class="cov0" title="0">return resp.InitPoint, nil</span>
}

func (g *MercadoPagoGateway) ProcessWebhook(ctx context.Context, payload interface{}) (*domain.Payment, error) <span class="cov0" title="0">{
        // Payload is expected to be the Payment ID (string or int)
        var paymentID int
        switch v := payload.(type) </span>{
        case string:<span class="cov0" title="0">
                id, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid payment id format: %w", err)
                }</span>
                <span class="cov0" title="0">paymentID = id</span>
        case int:<span class="cov0" title="0">
                paymentID = v</span>
        case int64:<span class="cov0" title="0">
                paymentID = int(v)</span>
        case float64:<span class="cov0" title="0">
                paymentID = int(v)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported payload type for webhook")</span>
        }

        <span class="cov0" title="0">cfg, err := config.New(g.accessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client := mp_payment.NewClient(cfg)
        mpdata, err := client.Get(ctx, paymentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch payment from MP: %w", err)
        }</span>

        // Map Status
        <span class="cov0" title="0">status := domain.PaymentStatusPending
        if mpdata.Status == "approved" </span><span class="cov0" title="0">{
                status = domain.PaymentStatusCompleted
        }</span> else<span class="cov0" title="0"> if mpdata.Status == "rejected" || mpdata.Status == "cancelled" </span><span class="cov0" title="0">{
                status = domain.PaymentStatusFailed
        }</span> else<span class="cov0" title="0"> if mpdata.Status == "refunded" </span><span class="cov0" title="0">{
                status = domain.PaymentStatusRefunded
        }</span>

        // Extract External Reference (Our Payment UUID)
        <span class="cov0" title="0">paymentUUID, err := uuid.Parse(mpdata.ExternalReference)
        if err != nil </span><span class="cov0" title="0">{
                // Log warning?
                return nil, fmt.Errorf("invalid external reference in MP payment: %s", mpdata.ExternalReference)
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return &amp;domain.Payment{
                ID:         paymentUUID,
                Status:     status,
                ExternalID: strconv.Itoa(paymentID),
                Method:     domain.PaymentMethodMercadoPago,
                PaidAt:     &amp;now, // Approximate
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package http

import (
        "log"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/domain"
        "github.com/shopspring/decimal"
)

type PaymentHandler struct {
        repo    domain.PaymentRepository
        gateway domain.PaymentGateway
}

func NewPaymentHandler(repo domain.PaymentRepository, gateway domain.PaymentGateway) *PaymentHandler <span class="cov0" title="0">{
        return &amp;PaymentHandler{
                repo:    repo,
                gateway: gateway,
        }
}</span>

type CheckoutRequest struct {
        Amount        float64 `json:"amount" binding:"required"`
        Description   string  `json:"description" binding:"required"`
        PayerEmail    string  `json:"payer_email" binding:"required,email"`
        ReferenceID   string  `json:"reference_id" binding:"required"`
        ReferenceType string  `json:"reference_type" binding:"required"` // MEMBERSHIP, BOOKING
}

// Checkout creates a payment Intent and returns the MP Preference URL
func (h *PaymentHandler) Checkout(c *gin.Context) <span class="cov0" title="0">{
        var req CheckoutRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // 1. Create Payment Record (Pending)
        // We assume PayerID comes from Context (Auth Middleware)
        <span class="cov0" title="0">userIDStr := c.GetString("userID")
        var userID uuid.UUID
        var err error

        if userIDStr != "" </span><span class="cov0" title="0">{
                userID, err = uuid.Parse(userIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Invalid User ID in context: %v", err)
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user session"})
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // If not authenticated (should be prevented by middleware), fail or prompt login
                // For now, we return 401
                c.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
                return
        }</span>

        <span class="cov0" title="0">refID, err := uuid.Parse(req.ReferenceID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid reference_id format"})
                return
        }</span>

        <span class="cov0" title="0">payment := &amp;domain.Payment{
                ID:            uuid.New(),
                Amount:        decimal.NewFromFloat(req.Amount),
                Currency:      "ARS",
                Status:        domain.PaymentStatusPending,
                Method:        domain.PaymentMethodMercadoPago, // Default for this endpoint
                PayerID:       userID,
                ReferenceID:   refID,
                ReferenceType: req.ReferenceType,
        }

        if err := h.repo.Create(c.Request.Context(), payment); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create payment: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create payment record", "details": err.Error()})
                return
        }</span>

        // 2. Call Gateway
        <span class="cov0" title="0">url, err := h.gateway.CreatePreference(c.Request.Context(), payment, req.PayerEmail, req.Description)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Gateway Error: %v", err)
                c.JSON(http.StatusBadGateway, gin.H{"error": "failed to contact payment gateway"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"url": url})</span>
}

// HandleWebhook receives notifications from payment providers
func (h *PaymentHandler) HandleWebhook(c *gin.Context) <span class="cov0" title="0">{
        // MP query param type=payment
        webhookType := c.Query("type")

        // Sometimes MP sends topic=payment
        if webhookType == "" </span><span class="cov0" title="0">{
                webhookType = c.Query("topic")
        }</span>

        <span class="cov0" title="0">if webhookType == "payment" </span><span class="cov0" title="0">{
                dataID := c.Query("data.id")
                if dataID == "" </span><span class="cov0" title="0">{
                        dataID = c.Query("id")
                }</span>

                <span class="cov0" title="0">if dataID != "" </span><span class="cov0" title="0">{
                        updatedPayment, err := h.gateway.ProcessWebhook(c.Request.Context(), dataID)
                        if err == nil &amp;&amp; updatedPayment != nil </span><span class="cov0" title="0">{
                                existing, err := h.repo.GetByID(c.Request.Context(), updatedPayment.ID)
                                if err == nil </span><span class="cov0" title="0">{
                                        existing.Status = updatedPayment.Status
                                        existing.PaidAt = updatedPayment.PaidAt
                                        existing.ExternalID = updatedPayment.ExternalID
                                        if err := h.repo.Update(c.Request.Context(), existing); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Failed to update payment status: %v", err)
                                        }</span>
                                        <span class="cov0" title="0">log.Printf("Payment %s updated to %s", existing.ID, existing.Status)</span>
                                } else<span class="cov0" title="0"> {
                                        log.Printf("Payment not found for update: %s", updatedPayment.ID)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                log.Printf("Webhook processing failed: %v", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">c.Status(http.StatusOK)</span>
}

func RegisterRoutes(r *gin.RouterGroup, handler *PaymentHandler, authMiddleware, tenantMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        payments := r.Group("/payments")
        </span><span class="cov0" title="0">{
                // Protected
                payments.POST("/checkout", authMiddleware, tenantMiddleware, handler.Checkout)

                // Public (Webhook)
                payments.POST("/webhook", handler.HandleWebhook)
        }</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package repository

import (
        "context"
        "errors"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/payment/domain"
        "gorm.io/gorm"
)

type PostgresPaymentRepository struct {
        db *gorm.DB
}

func NewPostgresPaymentRepository(db *gorm.DB) *PostgresPaymentRepository <span class="cov0" title="0">{
        return &amp;PostgresPaymentRepository{db: db}
}</span>

func (r *PostgresPaymentRepository) Create(ctx context.Context, payment *domain.Payment) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(payment).Error
}</span>

func (r *PostgresPaymentRepository) Update(ctx context.Context, payment *domain.Payment) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(payment).Error
}</span>

func (r *PostgresPaymentRepository) GetByID(ctx context.Context, id uuid.UUID) (*domain.Payment, error) <span class="cov0" title="0">{
        var payment domain.Payment
        if err := r.db.WithContext(ctx).First(&amp;payment, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;payment, nil</span>
}

func (r *PostgresPaymentRepository) GetByExternalID(ctx context.Context, externalID string) (*domain.Payment, error) <span class="cov0" title="0">{
        var payment domain.Payment
        if err := r.db.WithContext(ctx).First(&amp;payment, "external_id = ?", externalID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;payment, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package application

import (
        "errors"
        "time"

        "github.com/google/uuid"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/domain"
)

type UserUseCases struct {
        repo domain.UserRepository
}

func NewUserUseCases(repo domain.UserRepository) *UserUseCases <span class="cov0" title="0">{
        return &amp;UserUseCases{
                repo: repo,
        }
}</span>

func (uc *UserUseCases) GetProfile(clubID, userID string) (*domain.User, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("invalid user ID")
        }</span>
        <span class="cov0" title="0">return uc.repo.GetByID(clubID, userID)</span>
}

type UpdateProfileDTO struct {
        Name              string                 `json:"name"`
        DateOfBirth       *time.Time             `json:"date_of_birth"`
        SportsPreferences map[string]interface{} `json:"sports_preferences"`
}

func (uc *UserUseCases) UpdateProfile(clubID, userID string, dto UpdateProfileDTO) (*domain.User, error) <span class="cov0" title="0">{
        user, err := uc.repo.GetByID(clubID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>

        // Update fields
        <span class="cov0" title="0">if dto.Name != "" </span><span class="cov0" title="0">{
                user.Name = dto.Name
        }</span>
        <span class="cov0" title="0">if dto.DateOfBirth != nil </span><span class="cov0" title="0">{
                user.DateOfBirth = dto.DateOfBirth
        }</span>
        <span class="cov0" title="0">if dto.SportsPreferences != nil </span><span class="cov0" title="0">{
                user.SportsPreferences = dto.SportsPreferences
        }</span>

        // Update timestamp
        <span class="cov0" title="0">user.UpdatedAt = time.Now()

        if err := uc.repo.Update(user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (uc *UserUseCases) DeleteUser(clubID, id string, requesterID string) error <span class="cov0" title="0">{
        if id == requesterID </span><span class="cov0" title="0">{
                return errors.New("cannot delete yourself")
        }</span>
        <span class="cov0" title="0">return uc.repo.Delete(clubID, id)</span>
}

func (uc *UserUseCases) ListUsers(clubID string, limit, offset int, search string) ([]domain.User, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">filters := make(map[string]interface{})
        if search != "" </span><span class="cov0" title="0">{
                filters["search"] = search
        }</span>

        <span class="cov0" title="0">return uc.repo.List(clubID, limit, offset, filters)</span>
}

func (uc *UserUseCases) ListChildren(clubID, parentID string) ([]domain.User, error) <span class="cov0" title="0">{
        if parentID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("parent ID required")
        }</span>
        <span class="cov0" title="0">return uc.repo.FindChildren(clubID, parentID)</span>
}

type RegisterChildDTO struct {
        Name        string     `json:"name"`
        Email       string     `json:"email"` // Optional for very young children? Let's say required for uniqueness or consistency.
        DateOfBirth *time.Time `json:"date_of_birth"`
}

func (uc *UserUseCases) RegisterChild(clubID, parentID string, dto RegisterChildDTO) (*domain.User, error) <span class="cov0" title="0">{
        if parentID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("parent ID required")
        }</span>
        <span class="cov0" title="0">if dto.Name == "" </span><span class="cov0" title="0">{
                return nil, errors.New("name is required")
        }</span>

        // Email Logic:
        // If email is provided, check uniqueness (repo check or constraint).
        // If not provided, maybe generate a dummy one? email column is unique not null usually.
        // For now, require email or generate one like child.UUID@placeholder.club
        <span class="cov0" title="0">email := dto.Email
        if email == "" </span><span class="cov0" title="0">{
                email = "child." + uuid.New().String() + "@placeholder.com"
        }</span>

        <span class="cov0" title="0">child := &amp;domain.User{
                ID:          uuid.New().String(),
                ClubID:      clubID,
                Name:        dto.Name,
                Email:       email,
                Role:        "USER", // Or "CHILD" if we had that role
                DateOfBirth: dto.DateOfBirth,
                ParentID:    &amp;parentID,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        if err := uc.repo.Create(child); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return child, nil</span>
}

func (uc *UserUseCases) GetStats(clubID, userID string) (*domain.UserStats, error) <span class="cov0" title="0">{
        user, err := uc.repo.GetByID(clubID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>
        <span class="cov0" title="0">return user.Stats, nil</span>
}

func (uc *UserUseCases) GetWallet(clubID, userID string) (*domain.Wallet, error) <span class="cov0" title="0">{
        user, err := uc.repo.GetByID(clubID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>
        <span class="cov0" title="0">return user.Wallet, nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package domain

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "time"

        "github.com/google/uuid"
)

type Transaction struct {
        ID          string    `json:"id"`
        Type        string    `json:"type"` // "credit", "debit"
        Amount      float64   `json:"amount"`
        Description string    `json:"description"`
        Date        time.Time `json:"date"`
}

type TransactionHistory []Transaction

func (t TransactionHistory) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(t)
}</span>

func (t *TransactionHistory) Scan(value interface{}) error <span class="cov0" title="0">{
        b, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("type assertion to []byte failed")
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(b, t)</span>
}

type Wallet struct {
        ID           uuid.UUID          `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        UserID       string             `json:"user_id" gorm:"type:varchar(100);not null;uniqueIndex"`
        Balance      float64            `json:"balance" gorm:"default:0.0"`
        Points       int                `json:"points" gorm:"default:0"`
        Transactions TransactionHistory `json:"transactions" gorm:"type:jsonb"`
        CreatedAt    time.Time          `json:"created_at"`
        UpdatedAt    time.Time          `json:"updated_at"`
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package domain

import "time"

type User struct {
        ID                string                 `json:"id"`
        Name              string                 `json:"name"`
        Email             string                 `json:"email"`
        Role              string                 `json:"role"`
        CreatedAt         time.Time              `json:"created_at"`
        UpdatedAt         time.Time              `json:"updated_at"`
        DateOfBirth       *time.Time             `json:"date_of_birth,omitempty"`
        SportsPreferences map[string]interface{} `json:"sports_preferences,omitempty"`
        ParentID          *string                `json:"parent_id,omitempty"`
        ClubID            string                 `json:"club_id" gorm:"index;not null"`

        // Relations (Fetched on demand or preloaded)
        Stats  *UserStats `json:"stats,omitempty" gorm:"foreignKey:UserID;references:ID"`
        Wallet *Wallet    `json:"wallet,omitempty" gorm:"foreignKey:UserID;references:ID"`
}

const (
        RoleSuperAdmin = "SUPER_ADMIN"
        RoleAdmin      = "ADMIN"
        RoleMember     = "MEMBER"
)

// CalculateCategory returns the user's category based on birth year (e.g., "2012")
func (u *User) CalculateCategory() string <span class="cov8" title="1">{
        if u.DateOfBirth == nil </span><span class="cov8" title="1">{
                return "Files" // Default category if unknown
        }</span>
        <span class="cov8" title="1">return u.DateOfBirth.Format("2006")</span>
}

type UserRepository interface {
        GetByID(clubID, id string) (*User, error)
        // Update updates the non-auth fields of the user
        Update(user *User) error
        Delete(clubID, id string) error
        List(clubID string, limit, offset int, filters map[string]interface{}) ([]User, error)
        FindChildren(clubID, parentID string) ([]User, error)
        Create(user *User) error
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package http

import (
        "net/http"

        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/domain"

        "github.com/gin-gonic/gin"
        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/application"
)

type UserHandler struct {
        useCases *application.UserUseCases
}

func NewUserHandler(useCases *application.UserUseCases) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                useCases: useCases,
        }
}</span>

type UserResponse struct {
        *domain.User
        Category string `json:"category"`
}

func (h *UserHandler) GetProfile(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        // Extract ClubID
        <span class="cov0" title="0">clubID := c.GetString("clubID")
        role := c.GetString("userRole")

        // Super Admin special handling: their user record is in "system" default club
        if role == domain.RoleSuperAdmin </span><span class="cov0" title="0">{
                clubID = "system"
        }</span>

        <span class="cov0" title="0">if clubID == "" </span><span class="cov0" title="0">{
                // Should be handled by middleware, but safety check
                c.JSON(http.StatusBadRequest, gin.H{"error": "Club context missing"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.useCases.GetProfile(clubID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        <span class="cov0" title="0">response := UserResponse{
                User:     user,
                Category: user.CalculateCategory(),
        }

        c.JSON(http.StatusOK, response)</span>
}

func (h *UserHandler) UpdateProfile(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">var dto application.UpdateProfileDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        // Super Admin lives in system club
        role := c.GetString("userRole")
        if role == domain.RoleSuperAdmin </span><span class="cov0" title="0">{
                clubID = "system"
        }</span>

        <span class="cov0" title="0">user, err := h.useCases.UpdateProfile(clubID, userID.(string), dto)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}

func (h *UserHandler) ListUsers(c *gin.Context) <span class="cov0" title="0">{
        limit := 10
        offset := 0
        // Parse basic pagination query params if needed, for now defaults
        // In real implementation: strconv.Atoi(c.Query("limit")) etc.
        search := c.Query("search")

        clubID := c.GetString("clubID")
        users, err := h.useCases.ListUsers(clubID, limit, offset, search)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": users})</span> // Wrap in data envelope
}

func (h *UserHandler) DeleteUser(c *gin.Context) <span class="cov0" title="0">{
        deleteID := c.Param("id")
        if deleteID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "User ID required"})
                return
        }</span>

        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        if err := h.useCases.DeleteUser(clubID, deleteID, userID.(string)); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()}) // Bad Request for logical limits
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *UserHandler) GetChildren(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        role := c.GetString("userRole")
        if role == domain.RoleSuperAdmin </span><span class="cov0" title="0">{
                clubID = "system"
        }</span>

        <span class="cov0" title="0">children, err := h.useCases.ListChildren(clubID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": children})</span>
}

func (h *UserHandler) RegisterChild(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">var dto application.RegisterChildDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        role := c.GetString("userRole")
        if role == domain.RoleSuperAdmin </span><span class="cov0" title="0">{
                clubID = "system"
        }</span>

        <span class="cov0" title="0">child, err := h.useCases.RegisterChild(clubID, userID.(string), dto)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{"data": child})</span>
}

func (h *UserHandler) GetStats(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        if id == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "User ID required"})
                return
        }</span>

        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">currentUserID := userID.(string)

        // "me" alias
        if id == "me" </span><span class="cov0" title="0">{
                id = currentUserID
        }</span> else<span class="cov0" title="0"> {
                // BOLA CHECK
                roleContext, _ := c.Get("userRole")
                role, _ := roleContext.(string)
                if id != currentUserID &amp;&amp; role != domain.RoleAdmin &amp;&amp; role != domain.RoleSuperAdmin </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
                        return
                }</span>
        }

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        // For "me" of Super Admin, use system. For others, use context.
        // But Super Admin can inspect others.
        role := c.GetString("userRole")
        if role == domain.RoleSuperAdmin &amp;&amp; id == currentUserID </span><span class="cov0" title="0">{
                clubID = "system"
        }</span>

        <span class="cov0" title="0">stats, err := h.useCases.GetStats(clubID, id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if stats == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"data": nil})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": stats})</span>
}

func (h *UserHandler) GetWallet(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        if id == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "User ID required"})
                return
        }</span>

        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">currentUserID := userID.(string)

        // "me" alias
        if id == "me" </span><span class="cov0" title="0">{
                id = currentUserID
        }</span> else<span class="cov0" title="0"> {
                // BOLA CHECK
                roleContext, _ := c.Get("userRole")
                role, _ := roleContext.(string)
                if id != currentUserID &amp;&amp; role != domain.RoleAdmin &amp;&amp; role != domain.RoleSuperAdmin </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
                        return
                }</span>
        }

        <span class="cov0" title="0">clubID := c.GetString("clubID")
        role := c.GetString("userRole")
        if role == domain.RoleSuperAdmin &amp;&amp; id == currentUserID </span><span class="cov0" title="0">{
                clubID = "system"
        }</span>

        <span class="cov0" title="0">wallet, err := h.useCases.GetWallet(clubID, id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if wallet == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"data": nil})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": wallet})</span>
}

func RegisterRoutes(r *gin.RouterGroup, handler *UserHandler, authMiddleware, tenantMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        users := r.Group("/users")
        users.Use(authMiddleware, tenantMiddleware) // Protect these routes with Auth THEN Tenant
        </span><span class="cov0" title="0">{
                users.GET("/me", handler.GetProfile)
                users.PUT("/me", handler.UpdateProfile)
                users.GET("/me/children", handler.GetChildren)
                users.POST("/me/children", handler.RegisterChild)
                users.GET("", handler.ListUsers)
                users.DELETE("/:id", handler.DeleteUser)
                users.GET("/:id/stats", handler.GetStats)
                users.GET("/:id/wallet", handler.GetWallet)
        }</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package repository

import (
        "errors"
        "time"

        "github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/domain"
        "gorm.io/gorm"
)

type PostgresUserRepository struct {
        db *gorm.DB
}

func NewPostgresUserRepository(db *gorm.DB) *PostgresUserRepository <span class="cov0" title="0">{
        // Auto-Migrate the new entities
        _ = db.AutoMigrate(&amp;domain.UserStats{}, &amp;domain.Wallet{})
        return &amp;PostgresUserRepository{db: db}
}</span>

// UserModel mirrors the database schema defined in Auth module.
// In a larger system, we might use a shared kernel, or duplicate/map.
// We duplicate here to keep modules decoupled in code, even if coupling in DB.
type UserModel struct {
        ID                string `gorm:"primaryKey"`
        Name              string
        Email             string
        Password          string `gorm:"not null"` // Added to support creation via User module, though mainly Auth managed.
        Role              string
        DateOfBirth       *time.Time             `gorm:"type:date"`
        SportsPreferences map[string]interface{} `gorm:"serializer:json"`
        ParentID          *string                `gorm:"index"`
        CreatedAt         time.Time
        UpdatedAt         time.Time
        DeletedAt         gorm.DeletedAt `gorm:"index"`
        // Join fields for GORM Preloading (mapping back to domain entities)
        Stats  *domain.UserStats `gorm:"foreignKey:UserID;references:ID"`
        Wallet *domain.Wallet    `gorm:"foreignKey:UserID;references:ID"`
        ClubID string            `gorm:"index;not null"`
}

func (UserModel) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>

func (r *PostgresUserRepository) GetByID(clubID, id string) (*domain.User, error) <span class="cov0" title="0">{
        var model UserModel
        // Preload Stats and Wallet
        result := r.db.Preload("Stats").Preload("Wallet").Where("id = ? AND club_id = ?", id, clubID).First(&amp;model)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil // Or specific domain error
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }

        <span class="cov0" title="0">return &amp;domain.User{
                ID:                model.ID,
                Name:              model.Name,
                Email:             model.Email,
                Role:              model.Role,
                DateOfBirth:       model.DateOfBirth,
                SportsPreferences: model.SportsPreferences,
                ParentID:          model.ParentID,
                CreatedAt:         model.CreatedAt,
                UpdatedAt:         model.UpdatedAt,
                Stats:             model.Stats,
                Wallet:            model.Wallet,
                ClubID:            model.ClubID,
        }, nil</span>
}

func (r *PostgresUserRepository) Update(user *domain.User) error <span class="cov0" title="0">{
        // We only update fields allowed by this module (e.g. Name, DoB, Preferences).
        updates := map[string]interface{}{
                "name":       user.Name,
                "updated_at": user.UpdatedAt,
                // ClubID is typically immutable or handled via admin, but if needed:
                // "club_id": user.ClubID,
        }
        if user.DateOfBirth != nil </span><span class="cov0" title="0">{
                updates["date_of_birth"] = user.DateOfBirth
        }</span>
        <span class="cov0" title="0">if user.SportsPreferences != nil </span><span class="cov0" title="0">{
                updates["sports_preferences"] = user.SportsPreferences
        }</span>

        <span class="cov0" title="0">result := r.db.Model(&amp;UserModel{ID: user.ID}).Updates(updates)

        return result.Error</span>
}

func (r *PostgresUserRepository) Delete(clubID, id string) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;UserModel{}, "id = ? AND club_id = ?", id, clubID).Error
}</span>

func (r *PostgresUserRepository) List(clubID string, limit, offset int, filters map[string]interface{}) ([]domain.User, error) <span class="cov0" title="0">{
        var models []UserModel
        query := r.db.Model(&amp;UserModel{}).Where("club_id = ?", clubID).Limit(limit).Offset(offset)

        if search, ok := filters["search"].(string); ok &amp;&amp; search != "" </span><span class="cov0" title="0">{
                // PostgreSQL ILIKE
                query = query.Where("name ILIKE ? OR email ILIKE ?", "%"+search+"%", "%"+search+"%")
        }</span>

        <span class="cov0" title="0">if category, ok := filters["category"].(string); ok &amp;&amp; category != "" </span><span class="cov0" title="0">{
                // Filter by Year of DateOfBirth
                // SQLite/Postgres syntax might differ slightly, but standard SQL is EXTRACT(YEAR FROM ...)
                // GORM: datatypes might be sensitive.
                query = query.Where("EXTRACT(YEAR FROM date_of_birth) = ?", category)
        }</span>

        <span class="cov0" title="0">result := query.Find(&amp;models)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">users := make([]domain.User, len(models))
        for i, model := range models </span><span class="cov0" title="0">{
                users[i] = domain.User{
                        ID:                model.ID,
                        Name:              model.Name,
                        Email:             model.Email,
                        Role:              model.Role,
                        DateOfBirth:       model.DateOfBirth,
                        SportsPreferences: model.SportsPreferences,
                        ParentID:          model.ParentID,
                        CreatedAt:         model.CreatedAt,
                        UpdatedAt:         model.UpdatedAt,
                        ClubID:            model.ClubID,
                }
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

func (r *PostgresUserRepository) FindChildren(clubID, parentID string) ([]domain.User, error) <span class="cov0" title="0">{
        var models []UserModel
        result := r.db.Where("parent_id = ? AND club_id = ?", parentID, clubID).Find(&amp;models)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">users := make([]domain.User, len(models))
        for i, m := range models </span><span class="cov0" title="0">{
                users[i] = domain.User{
                        ID:                m.ID,
                        Name:              m.Name,
                        Email:             m.Email,
                        Role:              m.Role,
                        DateOfBirth:       m.DateOfBirth,
                        ParentID:          m.ParentID,
                        SportsPreferences: m.SportsPreferences,
                        CreatedAt:         m.CreatedAt,
                        UpdatedAt:         m.UpdatedAt,
                        ClubID:            m.ClubID,
                }
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

func (r *PostgresUserRepository) Create(user *domain.User) error <span class="cov0" title="0">{
        model := UserModel{
                ID:                user.ID,
                Name:              user.Name,
                Email:             user.Email,
                Role:              user.Role,
                DateOfBirth:       user.DateOfBirth,
                SportsPreferences: user.SportsPreferences,
                ParentID:          user.ParentID,
                CreatedAt:         user.CreatedAt,
                UpdatedAt:         user.UpdatedAt,
                ClubID:            user.ClubID,
        }

        // Note: We are relying on the DB/GORM to ignore or default fields not present here (like password)
        // But since this is creating a "User", the Auth module model requires Password.
        // For "Children" managed by parents, they might not have login credentials initially,
        // OR we generate a placeholder.
        // However, GORM might fail constraint "not null" on password if defined in migration.
        // Let's assume we handle creation gracefully, potentially setting a default hash if needed by DB.
        // In the actual system, Auth logic handles creation.
        // If we use User module to create, we might be bypassing Auth constraints.
        // BUT, for Phase 7/8, we are pragmatic.
        // Let's assume we set a dummy password hash if empty? Or the DB allows null?
        // Checking Auth migration: Password string `gorm:"not null"`.
        // So we MUST provide a password.
        // We'll set a placeholder in the UseCase, here we just save what is given.
        if model.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                model.CreatedAt = time.Now()
        }</span>
        <span class="cov0" title="0">if model.UpdatedAt.IsZero() </span><span class="cov0" title="0">{
                model.UpdatedAt = time.Now()
        }</span>
        <span class="cov0" title="0">model.Password = "$2a$10$PlaceholderHashForChildAcc" // Dummy hash to satisfy constraint if not provided in struct (which isn't)
        // Wait, UserModel in this file does NOT have Password field.
        // If we create here, GORM uses THIS struct model.
        // If Schema has Password column NOT NULL, and we insert without it, Postgres will Error.
        // We must add Password to local UserModel or handle it.
        // Let's add Password to UserModel in this file to support creation.
        // Update: also need to set ClubID
        model.ClubID = user.ClubID

        return r.db.Create(&amp;model).Error</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package audit

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "sync"
        "time"

        platformRedis "github.com/lukcba/club-pulse-system-api/backend/internal/platform/redis"
        "gorm.io/gorm"
)

// AuditLog represents an audit log entry
type AuditLog struct {
        ID        string    `json:"id" gorm:"primaryKey"`
        UserID    string    `json:"user_id" gorm:"index"`
        Action    string    `json:"action" gorm:"index"`
        Resource  string    `json:"resource"`
        Details   string    `json:"details" gorm:"type:text"`
        IP        string    `json:"ip"`
        UserAgent string    `json:"user_agent"`
        Timestamp time.Time `json:"timestamp" gorm:"index"`
        CreatedAt time.Time `json:"created_at" gorm:"autoCreateTime"`
}

// TableName specifies the table name for GORM
func (AuditLog) TableName() string <span class="cov0" title="0">{
        return "audit_logs"
}</span>

const (
        auditQueueKey = "audit:queue"
        batchSize     = 100
)

// AuditQueue provides asynchronous audit logging via Redis
type AuditQueue struct {
        redis      *platformRedis.RedisClient
        db         *gorm.DB
        flushEvery time.Duration
        stopChan   chan struct{}
        wg         sync.WaitGroup
}

// NewAuditQueue creates a new audit queue
func NewAuditQueue(db *gorm.DB, flushEvery time.Duration) *AuditQueue <span class="cov0" title="0">{
        return &amp;AuditQueue{
                redis:      platformRedis.GetClient(),
                db:         db,
                flushEvery: flushEvery,
                stopChan:   make(chan struct{}),
        }
}</span>

// Push adds an audit log entry to the queue (non-blocking, ~0ms impact on request)
func (q *AuditQueue) Push(ctx context.Context, log *AuditLog) error <span class="cov0" title="0">{
        if log.ID == "" </span><span class="cov0" title="0">{
                log.ID = fmt.Sprintf("%d-%s", time.Now().UnixNano(), log.UserID[:8])
        }</span>
        <span class="cov0" title="0">if log.Timestamp.IsZero() </span><span class="cov0" title="0">{
                log.Timestamp = time.Now()
        }</span>

        <span class="cov0" title="0">data, err := json.Marshal(log)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal audit log: %w", err)
        }</span>

        <span class="cov0" title="0">return q.redis.LPush(ctx, auditQueueKey, string(data))</span>
}

// StartFlushWorker starts the background worker that flushes logs to PostgreSQL
func (q *AuditQueue) StartFlushWorker() <span class="cov0" title="0">{
        q.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer q.wg.Done()
                ticker := time.NewTicker(q.flushEvery)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                if err := q.Flush(context.Background()); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Audit queue flush error: %v", err)
                                }</span>
                        case &lt;-q.stopChan:<span class="cov0" title="0">
                                // Final flush before shutdown
                                _ = q.Flush(context.Background())
                                return</span>
                        }
                }
        }()
}

// Stop gracefully stops the flush worker
func (q *AuditQueue) Stop() <span class="cov0" title="0">{
        close(q.stopChan)
        q.wg.Wait()
}</span>

// Flush moves logs from Redis to PostgreSQL
func (q *AuditQueue) Flush(ctx context.Context) error <span class="cov0" title="0">{
        // Get batch of logs from Redis
        entries, err := q.redis.LRange(ctx, auditQueueKey, 0, batchSize-1)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read audit queue: %w", err)
        }</span>

        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Parse and collect logs
        <span class="cov0" title="0">var logs []AuditLog
        for _, entry := range entries </span><span class="cov0" title="0">{
                var auditLog AuditLog
                if err := json.Unmarshal([]byte(entry), &amp;auditLog); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to unmarshal audit log: %v", err)
                        continue</span>
                }
                <span class="cov0" title="0">logs = append(logs, auditLog)</span>
        }

        // Bulk insert to PostgreSQL
        <span class="cov0" title="0">if len(logs) &gt; 0 </span><span class="cov0" title="0">{
                if err := q.db.Create(&amp;logs).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to insert audit logs: %w", err)
                }</span>
        }

        // Remove processed entries from Redis
        <span class="cov0" title="0">if err := q.redis.LTrim(ctx, auditQueueKey, int64(len(entries)), -1); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to trim audit queue: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Flushed %d audit logs to PostgreSQL", len(logs))
        return nil</span>
}

// LogAction is a convenience method for logging common actions
func (q *AuditQueue) LogAction(ctx context.Context, userID, action, resource string, details map[string]interface{}, ip, userAgent string) <span class="cov0" title="0">{
        detailsJSON, _ := json.Marshal(details)
        _ = q.Push(ctx, &amp;AuditLog{
                UserID:    userID,
                Action:    action,
                Resource:  resource,
                Details:   string(detailsJSON),
                IP:        ip,
                UserAgent: userAgent,
        })
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package database

import (
        "fmt"
        "log"
        "os"
        "sync"
        "time"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

var (
        DB   *gorm.DB
        once sync.Once
)

// InitDB initializes the database connection
func InitDB() <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                dsn := fmt.Sprintf(
                        "host=%s user=%s password=%s dbname=%s port=%s sslmode=disable TimeZone=UTC",
                        getEnv("DB_HOST", "localhost"),
                        getEnv("DB_USER", "postgres"),
                        getEnv("DB_PASSWORD", "pulse_secret"),
                        getEnv("DB_NAME", "club_pulse"),
                        getEnv("DB_PORT", "5432"),
                )

                var err error
                config := &amp;gorm.Config{
                        Logger: logger.Default.LogMode(logger.Info),
                }

                // Retry logic for docker startup delay
                for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                        DB, err = gorm.Open(postgres.Open(dsn), config)
                        if err == nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">log.Printf("Failed to connect to database, retrying in 2 seconds... (%d/5)", i+1)
                        time.Sleep(2 * time.Second)</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Could not connect to database: %v", err)
                }</span>

                <span class="cov0" title="0">sqlDB, err := DB.DB()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Could not get database instance: %v", err)
                }</span>

                // Connection pool settings
                <span class="cov0" title="0">sqlDB.SetMaxIdleConns(10)
                sqlDB.SetMaxOpenConns(100)
                sqlDB.SetConnMaxLifetime(time.Hour)

                log.Println("Database connection established successfully")</span>
        })
}

// GetDB returns the database instance
func GetDB() *gorm.DB <span class="cov0" title="0">{
        if DB == nil </span><span class="cov0" title="0">{
                InitDB()
        }</span>
        <span class="cov0" title="0">return DB</span>
}

func getEnv(key, fallback string) string <span class="cov0" title="0">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return fallback</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package embedding

import (
        "math"
        "regexp"
        "strings"
        "unicode"

        "golang.org/x/text/runes"
        "golang.org/x/text/transform"
        "golang.org/x/text/unicode/norm"
)

// Dimension defines the embedding vector size
const Dimension = 256

// EmbeddingService generates text embeddings using a lightweight TF-IDF approach
// This is a zero-cost alternative to paid embedding APIs (OpenAI, etc.)
type EmbeddingService struct {
        vocabulary map[string]int
        idf        map[string]float32
}

// NewEmbeddingService creates a new embedding service with a base vocabulary
func NewEmbeddingService() *EmbeddingService <span class="cov0" title="0">{
        // Base vocabulary for sports/facilities domain
        baseVocab := []string{
                // Sports
                "tenis", "futbol", "basketball", "natacion", "golf", "paddle", "squash", "volleyball",
                "badminton", "handball", "hockey", "rugby", "atletismo", "gimnasia", "yoga", "pilates",
                "crossfit", "spinning", "aerobics", "boxeo", "karate", "judo", "taekwondo",
                // Facility types
                "cancha", "piscina", "gimnasio", "campo", "pista", "sala", "court", "pool", "gym", "field",
                // Features
                "techado", "cubierto", "iluminacion", "nocturno", "noche", "climatizado", "exterior",
                "interior", "cesped", "sintetico", "natural", "arcilla", "cemento", "madera", "parquet",
                "lluvia", "sol", "sombra", "ventilacion", "aire", "acondicionado",
                // Equipment
                "raqueta", "pelota", "red", "arco", "aro", "colchoneta", "pesas", "maquinas",
                // Size
                "grande", "mediano", "pequeno", "profesional", "amateur", "olimpico", "estandar",
                // Time
                "manana", "tarde", "noche", "madrugada", "horario", "disponible", "reserva",
                // Quality
                "premium", "vip", "exclusivo", "familiar", "infantil", "adultos", "mayores",
        }

        vocab := make(map[string]int)
        for i, word := range baseVocab </span><span class="cov0" title="0">{
                vocab[word] = i % Dimension
        }</span>

        <span class="cov0" title="0">return &amp;EmbeddingService{
                vocabulary: vocab,
                idf:        make(map[string]float32),
        }</span>
}

// GenerateEmbedding creates a vector representation of the input text
func (s *EmbeddingService) GenerateEmbedding(text string) []float32 <span class="cov0" title="0">{
        embedding := make([]float32, Dimension)

        // Tokenize and normalize
        tokens := s.tokenize(text)
        if len(tokens) == 0 </span><span class="cov0" title="0">{
                return embedding
        }</span>

        // Count term frequency
        <span class="cov0" title="0">tf := make(map[string]int)
        for _, token := range tokens </span><span class="cov0" title="0">{
                tf[token]++
        }</span>

        // Build embedding using vocabulary positions
        <span class="cov0" title="0">for token, count := range tf </span><span class="cov0" title="0">{
                // Get vocabulary position (hash if not in vocab)
                pos := s.getPosition(token)

                // TF component (log normalization)
                tfWeight := float32(1 + math.Log(float64(count)))

                // IDF component (use 1.0 if unknown, allowing unseen terms)
                idfWeight := float32(1.0)
                if w, ok := s.idf[token]; ok </span><span class="cov0" title="0">{
                        idfWeight = w
                }</span>

                // Add to embedding position
                <span class="cov0" title="0">embedding[pos] += tfWeight * idfWeight</span>
        }

        // L2 normalize the embedding
        <span class="cov0" title="0">s.normalize(embedding)

        return embedding</span>
}

// tokenize splits text into normalized tokens
func (s *EmbeddingService) tokenize(text string) []string <span class="cov0" title="0">{
        // Lowercase
        text = strings.ToLower(text)

        // Remove accents
        t := transform.Chain(norm.NFD, runes.Remove(runes.In(unicode.Mn)), norm.NFC)
        text, _, _ = transform.String(t, text)

        // Split by non-alphanumeric
        re := regexp.MustCompile(`[^a-z0-9]+`)
        words := re.Split(text, -1)

        // Filter empty and short words
        var tokens []string
        for _, word := range words </span><span class="cov0" title="0">{
                if len(word) &gt; 2 </span><span class="cov0" title="0">{
                        tokens = append(tokens, word)
                }</span>
        }

        <span class="cov0" title="0">return tokens</span>
}

// getPosition returns the embedding dimension position for a token
func (s *EmbeddingService) getPosition(token string) int <span class="cov0" title="0">{
        if pos, ok := s.vocabulary[token]; ok </span><span class="cov0" title="0">{
                return pos
        }</span>
        // Hash unknown tokens to a position
        <span class="cov0" title="0">return s.hash(token) % Dimension</span>
}

// hash creates a simple hash for unknown tokens
func (s *EmbeddingService) hash(token string) int <span class="cov0" title="0">{
        h := 0
        for _, c := range token </span><span class="cov0" title="0">{
                h = 31*h + int(c)
        }</span>
        <span class="cov0" title="0">if h &lt; 0 </span><span class="cov0" title="0">{
                h = -h
        }</span>
        <span class="cov0" title="0">return h</span>
}

// normalize applies L2 normalization to the embedding
func (s *EmbeddingService) normalize(embedding []float32) <span class="cov0" title="0">{
        var sum float64
        for _, v := range embedding </span><span class="cov0" title="0">{
                sum += float64(v * v)
        }</span>

        <span class="cov0" title="0">if sum == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">norm := float32(math.Sqrt(sum))
        for i := range embedding </span><span class="cov0" title="0">{
                embedding[i] /= norm
        }</span>
}

// CosineSimilarity calculates the cosine similarity between two embeddings
func CosineSimilarity(a, b []float32) float32 <span class="cov0" title="0">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var dot, normA, normB float64
        for i := range a </span><span class="cov0" title="0">{
                dot += float64(a[i]) * float64(b[i])
                normA += float64(a[i]) * float64(a[i])
                normB += float64(b[i]) * float64(b[i])
        }</span>

        <span class="cov0" title="0">if normA == 0 || normB == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return float32(dot / (math.Sqrt(normA) * math.Sqrt(normB)))</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package middlewares

import (
        "net/http"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "golang.org/x/time/rate"
)

// RateLimiter manages rate limits per IP
type IPRateLimiter struct {
        ips map[string]*rate.Limiter
        mu  *sync.RWMutex
        r   rate.Limit
        b   int
}

func NewIPRateLimiter(r rate.Limit, b int) *IPRateLimiter <span class="cov0" title="0">{
        i := &amp;IPRateLimiter{
                ips: make(map[string]*rate.Limiter),
                mu:  &amp;sync.RWMutex{},
                r:   r,
                b:   b,
        }

        // Cleanup routine to remove old IPs could be added here
        go i.cleanupRoutine()

        return i
}</span>

func (i *IPRateLimiter) GetLimiter(ip string) *rate.Limiter <span class="cov0" title="0">{
        i.mu.Lock()
        defer i.mu.Unlock()

        limiter, exists := i.ips[ip]
        if !exists </span><span class="cov0" title="0">{
                limiter = rate.NewLimiter(i.r, i.b)
                i.ips[ip] = limiter
        }</span>

        <span class="cov0" title="0">return limiter</span>
}

func (i *IPRateLimiter) cleanupRoutine() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                time.Sleep(3 * time.Minute)
                i.mu.Lock()
                // Simple map reset for MVP to prevent memory leak
                // A proper LRU or timestamp check is better for production
                if len(i.ips) &gt; 10000 </span><span class="cov0" title="0">{
                        i.ips = make(map[string]*rate.Limiter)
                }</span>
                <span class="cov0" title="0">i.mu.Unlock()</span>
        }
}

// Global limiter instance (Singleton for simplicity in MVP)
// Allow 20 requests per second with burst of 40
var globalLimiter = NewIPRateLimiter(20, 40)

func RateLimitMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                ip := c.ClientIP()
                limiter := globalLimiter.GetLimiter(ip)

                if !limiter.Allow() </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
                                "error": "Too many requests",
                                "code":  http.StatusTooManyRequests,
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package middlewares

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        platformRedis "github.com/lukcba/club-pulse-system-api/backend/internal/platform/redis"
)

// RedisRateLimiter implements rate limiting using Redis sliding window
type RedisRateLimiter struct {
        redis  *platformRedis.RedisClient
        limit  int
        window time.Duration
}

// NewRedisRateLimiter creates a new Redis-based rate limiter
func NewRedisRateLimiter(limit int, window time.Duration) *RedisRateLimiter <span class="cov0" title="0">{
        return &amp;RedisRateLimiter{
                redis:  platformRedis.GetClient(),
                limit:  limit,
                window: window,
        }
}</span>

// Allow checks if a request is allowed based on rate limits
func (r *RedisRateLimiter) Allow(ctx context.Context, ip string) (allowed bool, remaining int) <span class="cov0" title="0">{
        // Key based on IP and current window
        windowStart := time.Now().Unix() / int64(r.window.Seconds())
        key := fmt.Sprintf("ratelimit:%s:%d", ip, windowStart)

        count, err := r.redis.Incr(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                // If Redis is unavailable, allow the request (fail open)
                return true, r.limit
        }</span>

        // Set TTL on first request in this window
        <span class="cov0" title="0">if count == 1 </span><span class="cov0" title="0">{
                _ = r.redis.Expire(ctx, key, r.window)
        }</span>

        <span class="cov0" title="0">remaining = r.limit - int(count)
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                remaining = 0
        }</span>

        <span class="cov0" title="0">return count &lt;= int64(r.limit), remaining</span>
}

// Global Redis rate limiter instance
var globalRedisLimiter *RedisRateLimiter

// InitRedisRateLimiter initializes the global Redis rate limiter
func InitRedisRateLimiter(limit int, window time.Duration) <span class="cov0" title="0">{
        globalRedisLimiter = NewRedisRateLimiter(limit, window)
}</span>

// RedisRateLimitMiddleware creates a Gin middleware for Redis-based rate limiting
func RedisRateLimitMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        // Initialize with defaults if not already initialized
        if globalRedisLimiter == nil </span><span class="cov0" title="0">{
                InitRedisRateLimiter(100, time.Minute) // 100 requests per minute
        }</span>

        <span class="cov0" title="0">return func(c *gin.Context) </span><span class="cov0" title="0">{
                ip := c.ClientIP()
                ctx := context.Background()

                allowed, remaining := globalRedisLimiter.Allow(ctx, ip)

                // Add rate limit headers
                c.Header("X-RateLimit-Limit", fmt.Sprintf("%d", globalRedisLimiter.limit))
                c.Header("X-RateLimit-Remaining", fmt.Sprintf("%d", remaining))
                c.Header("X-RateLimit-Reset", fmt.Sprintf("%d", time.Now().Add(globalRedisLimiter.window).Unix()))

                if !allowed </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
                                "error":   "Too many requests",
                                "code":    http.StatusTooManyRequests,
                                "message": "Rate limit exceeded. Please try again later.",
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package middlewares

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

// SecurityHeadersMiddleware adds OWASP recommended security headers
func SecurityHeadersMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // HSTS - Enforce HTTPS for 1 year
                c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")

                // Prevent MIME-type sniffing
                c.Header("X-Content-Type-Options", "nosniff")

                // Prevent clickjacking
                c.Header("X-Frame-Options", "DENY")

                // XSS Protection (Legacy browsers)
                c.Header("X-XSS-Protection", "1; mode=block")

                // Content Security Policy - Restrict sources
                // Adjust this based on frontend needs (e.g. allowing scripts from specific CDNs)
                c.Header("Content-Security-Policy", "default-src 'self'; img-src 'self' data:; font-src 'self'; script-src 'self'")

                // Referrer Policy
                c.Header("Referrer-Policy", "strict-origin-when-cross-origin")

                c.Next()
        }</span>
}

// CORSMiddleware configures Cross-Origin Resource Sharing
func CORSMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // In production, replace "*" with specific allowed origins from config
                // origin := c.Request.Header.Get("Origin")
                // if isAllowedOrigin(origin) {
                //         c.Header("Access-Control-Allow-Origin", origin)
                // }

                // For MVP/Dev, we can be slightly permissive but strict on methods/headers
                origin := c.Request.Header.Get("Origin")
                // fmt.Printf("DEBUG CORS: Origin=%s Method=%s Path=%s\n", origin, c.Request.Method, c.Request.URL.Path)

                if origin != "" </span><span class="cov0" title="0">{
                        c.Header("Access-Control-Allow-Origin", origin) // Dynamic allow for localhost:3000
                }</span> else <span class="cov0" title="0">{
                        // Fallback for tools or direct access?
                        // c.Header("Access-Control-Allow-Origin", "*") // Don't do this with Credentials=true
                }</span>
                <span class="cov0" title="0">c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE, PATCH")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Club-ID")
                c.Header("Access-Control-Allow-Credentials", "true")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package logger

import (
        "log/slog"
        "os"
)

// InitLogger initializes the global logger with JSON handler
func InitLogger() <span class="cov0" title="0">{
        opts := &amp;slog.HandlerOptions{
                Level: slog.LevelDebug, // Default to debug for dev; make configurable later
                ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr </span><span class="cov0" title="0">{
                        // Customize keys if needed, e.g. "time" -&gt; "@timestamp"
                        return a
                }</span>,
        }

        <span class="cov0" title="0">handler := slog.NewJSONHandler(os.Stdout, opts)
        logger := slog.New(handler)
        slog.SetDefault(logger)</span>
}

func Info(msg string, args ...any) <span class="cov0" title="0">{
        slog.Info(msg, args...)
}</span>

func Error(msg string, args ...any) <span class="cov0" title="0">{
        slog.Error(msg, args...)
}</span>

func Debug(msg string, args ...any) <span class="cov0" title="0">{
        slog.Debug(msg, args...)
}</span>

func Warn(msg string, args ...any) <span class="cov0" title="0">{
        slog.Warn(msg, args...)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package middleware

import (
        "log/slog"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.opentelemetry.io/otel/trace"
)

// StructuredLogger logs request details in JSON format
func StructuredLogger() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                path := c.Request.URL.Path
                raw := c.Request.URL.RawQuery
                method := c.Request.Method

                // Get Trace ID from OTel if available
                spanContext := trace.SpanContextFromContext(c.Request.Context())
                var traceID string
                if spanContext.HasTraceID() </span><span class="cov0" title="0">{
                        traceID = spanContext.TraceID().String()
                }</span> else<span class="cov0" title="0"> {
                        // Fallback (or if OTel middleware is missing/disabled)
                        traceID = c.GetHeader("X-Trace-ID")
                        if traceID == "" </span><span class="cov0" title="0">{
                                traceID = uuid.New().String()
                        }</span>
                }

                // Ensure it's in header for downstream if not already handled by propagator
                <span class="cov0" title="0">c.Header("X-Trace-ID", traceID)

                // Process Request
                c.Next()

                // Calculate Latency
                latency := time.Since(start)
                statusCode := c.Writer.Status()
                clientIP := c.ClientIP()
                errorMessage := c.Errors.ByType(gin.ErrorTypePrivate).String()

                // Log Level based on status
                level := slog.LevelInfo
                if statusCode &gt;= 500 </span><span class="cov0" title="0">{
                        level = slog.LevelError
                }</span> else<span class="cov0" title="0"> if statusCode &gt;= 400 </span><span class="cov0" title="0">{
                        level = slog.LevelWarn
                }</span>

                // Structured Log Attributes
                <span class="cov0" title="0">attrs := []any{
                        slog.String("trace_id", traceID),
                        slog.String("method", method),
                        slog.String("path", path),
                        slog.Int("status", statusCode),
                        slog.Duration("latency", latency),
                        slog.String("ip", clientIP),
                }

                if raw != "" </span><span class="cov0" title="0">{
                        attrs = append(attrs, slog.String("query", raw))
                }</span>
                <span class="cov0" title="0">if errorMessage != "" </span><span class="cov0" title="0">{
                        attrs = append(attrs, slog.String("error", errorMessage))
                }</span>

                // Add User Metadata if present
                <span class="cov0" title="0">if userID, exists := c.Get("userID"); exists </span><span class="cov0" title="0">{
                        attrs = append(attrs, slog.Any("user_id", userID))
                }</span>
                <span class="cov0" title="0">if clubID, exists := c.Get("userClubID"); exists </span><span class="cov0" title="0">{
                        attrs = append(attrs, slog.Any("club_id", clubID))
                }</span>

                <span class="cov0" title="0">slog.Log(c.Request.Context(), level, "HTTP Request", attrs...)</span>
        }
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package middleware

import (
        "net/http"

        "github.com/gin-gonic/gin"
        clubDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/club/domain"
        userDomain "github.com/lukcba/club-pulse-system-api/backend/internal/modules/user/domain"
)

const HeaderClubID = "X-Club-ID"
const ContextClubID = "clubID"
const ContextUserRole = "userRole"

func TenantMiddleware(clubRepo clubDomain.ClubRepository) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Public Routes Bypass
                publicPaths := map[string]bool{
                        "/api/v1/health":        true,
                        "/api/v1/auth/login":    true,
                        "/api/v1/auth/register": true,
                        "/api/v1/auth/refresh":  true,
                        "/api/v1/auth/google":   true,
                }
                if publicPaths[c.Request.URL.Path] </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">clubID := c.GetHeader(HeaderClubID)

                // 1. Get Auth Context
                role, _ := c.Get(ContextUserRole)
                tokenClubID, _ := c.Get("userClubID")

                // 2. Super Admin Bypass (Trust Header if provided, otherwise context optional)
                if role == userDomain.RoleSuperAdmin </span><span class="cov0" title="0">{
                        if clubID != "" </span><span class="cov0" title="0">{
                                c.Set(ContextClubID, clubID)
                        }</span> else <span class="cov0" title="0">{
                                // No header? Use token club? Or just proceed?
                                // SuperAdmin might operate cross-club.
                                // For now trust header if present.
                        }</span>
                        <span class="cov0" title="0">c.Next()
                        return</span>
                }

                // 3. Strict Validation for Regular Users
                // Header is optional if we trust token implicitly, BUT legacy frontend sends header.
                // CRITICAL: Ensure Header (if present) == Token Club ID
                <span class="cov0" title="0">userClubID, ok := tokenClubID.(string)
                if !ok || userClubID == "" </span><span class="cov0" title="0">{
                        // Should be caught by AuthMiddleware, but defensive programming
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "User context invalid"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if clubID != "" &amp;&amp; clubID != userClubID </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "Access denied to this club"})
                        c.Abort()
                        return
                }</span>

                // Force Context to be the verified User Club ID
                <span class="cov0" title="0">c.Set(ContextClubID, userClubID)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package redis

import (
        "context"
        "fmt"
        "log"
        "os"
        "sync"
        "time"

        "github.com/redis/go-redis/v9"
)

var (
        client *RedisClient
        once   sync.Once
)

// RedisClient wraps the go-redis client with helper methods
type RedisClient struct {
        rdb *redis.Client
}

// InitRedis initializes the Redis connection
func InitRedis() <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                host := getEnv("REDIS_HOST", "localhost")
                port := getEnv("REDIS_PORT", "6379")
                password := getEnv("REDIS_PASSWORD", "")

                rdb := redis.NewClient(&amp;redis.Options{
                        Addr:         fmt.Sprintf("%s:%s", host, port),
                        Password:     password,
                        DB:           0,
                        PoolSize:     100,
                        MinIdleConns: 10,
                        DialTimeout:  5 * time.Second,
                        ReadTimeout:  3 * time.Second,
                        WriteTimeout: 3 * time.Second,
                })

                // Test connection with retries
                ctx := context.Background()
                for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                        _, err := rdb.Ping(ctx).Result()
                        if err == nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">log.Printf("Failed to connect to Redis, retrying in 2 seconds... (%d/5)", i+1)
                        time.Sleep(2 * time.Second)</span>
                }

                // Final ping (will panic if still not connected)
                <span class="cov0" title="0">if _, err := rdb.Ping(ctx).Result(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Redis not available, some features disabled: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        log.Println("Redis connection established successfully")
                }</span>

                <span class="cov0" title="0">client = &amp;RedisClient{rdb: rdb}</span>
        })
}

// GetClient returns the Redis client instance
func GetClient() *RedisClient <span class="cov0" title="0">{
        if client == nil </span><span class="cov0" title="0">{
                InitRedis()
        }</span>
        <span class="cov0" title="0">return client</span>
}

// Close closes the Redis connection
func (r *RedisClient) Close() error <span class="cov0" title="0">{
        return r.rdb.Close()
}</span>

// --- Basic Operations ---

// Set stores a key-value with optional TTL
func (r *RedisClient) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov0" title="0">{
        return r.rdb.Set(ctx, key, value, ttl).Err()
}</span>

// Get retrieves a value by key
func (r *RedisClient) Get(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        return r.rdb.Get(ctx, key).Result()
}</span>

// Del deletes one or more keys
func (r *RedisClient) Del(ctx context.Context, keys ...string) error <span class="cov0" title="0">{
        return r.rdb.Del(ctx, keys...).Err()
}</span>

// Exists checks if a key exists
func (r *RedisClient) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        result, err := r.rdb.Exists(ctx, key).Result()
        return result &gt; 0, err
}</span>

// --- Rate Limiting Operations ---

// Incr increments a key and returns the new value
func (r *RedisClient) Incr(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        return r.rdb.Incr(ctx, key).Result()
}</span>

// Expire sets a TTL on a key
func (r *RedisClient) Expire(ctx context.Context, key string, ttl time.Duration) error <span class="cov0" title="0">{
        return r.rdb.Expire(ctx, key, ttl).Err()
}</span>

// --- Session Operations ---

// SetNX sets a key only if it doesn't exist (for locks)
func (r *RedisClient) SetNX(ctx context.Context, key string, value interface{}, ttl time.Duration) (bool, error) <span class="cov0" title="0">{
        return r.rdb.SetNX(ctx, key, value, ttl).Result()
}</span>

// Scan iterates over keys matching a pattern
func (r *RedisClient) Scan(ctx context.Context, pattern string) ([]string, error) <span class="cov0" title="0">{
        var keys []string
        iter := r.rdb.Scan(ctx, 0, pattern, 100).Iterator()
        for iter.Next(ctx) </span><span class="cov0" title="0">{
                keys = append(keys, iter.Val())
        }</span>
        <span class="cov0" title="0">return keys, iter.Err()</span>
}

// --- Pub/Sub Operations ---

// Publish sends a message to a channel
func (r *RedisClient) Publish(ctx context.Context, channel string, message interface{}) error <span class="cov0" title="0">{
        return r.rdb.Publish(ctx, channel, message).Err()
}</span>

// Subscribe subscribes to a channel and returns a PubSub
func (r *RedisClient) Subscribe(ctx context.Context, channel string) *redis.PubSub <span class="cov0" title="0">{
        return r.rdb.Subscribe(ctx, channel)
}</span>

// --- List Operations (for Audit Queue) ---

// LPush pushes a value to the head of a list
func (r *RedisClient) LPush(ctx context.Context, key string, values ...interface{}) error <span class="cov0" title="0">{
        return r.rdb.LPush(ctx, key, values...).Err()
}</span>

// LRange gets a range of values from a list
func (r *RedisClient) LRange(ctx context.Context, key string, start, stop int64) ([]string, error) <span class="cov0" title="0">{
        return r.rdb.LRange(ctx, key, start, stop).Result()
}</span>

// LTrim trims a list to the specified range
func (r *RedisClient) LTrim(ctx context.Context, key string, start, stop int64) error <span class="cov0" title="0">{
        return r.rdb.LTrim(ctx, key, start, stop).Err()
}</span>

// --- Health Check ---

// Ping checks if Redis is available
func (r *RedisClient) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return r.rdb.Ping(ctx).Err()
}</span>

func getEnv(key, fallback string) string <span class="cov0" title="0">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return fallback</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package redis

import (
        "context"
        "encoding/json"
        "log"
        "time"

        goredis "github.com/redis/go-redis/v9"
)

// Event types
const (
        EventBookingCancelled = "booking.cancelled"
        EventSlotAvailable    = "slot.available"
        EventMaintenanceStart = "maintenance.start"
        EventMaintenanceEnd   = "maintenance.end"
)

// Channel names
const (
        ChannelBookings    = "clubpulse:bookings"
        ChannelMaintenance = "clubpulse:maintenance"
)

// BookingEvent represents a booking-related event
type BookingEvent struct {
        Type       string    `json:"type"`
        FacilityID string    `json:"facility_id"`
        StartTime  time.Time `json:"start_time"`
        EndTime    time.Time `json:"end_time"`
        UserID     string    `json:"user_id,omitempty"`
        Message    string    `json:"message,omitempty"`
        Timestamp  time.Time `json:"timestamp"`
}

// EventPublisher publishes events to Redis Pub/Sub
type EventPublisher struct {
        redis *RedisClient
}

// NewEventPublisher creates a new event publisher
func NewEventPublisher() *EventPublisher <span class="cov0" title="0">{
        return &amp;EventPublisher{
                redis: GetClient(),
        }
}</span>

// PublishBookingCancelled notifies that a booking was cancelled (slot is now available)
func (p *EventPublisher) PublishBookingCancelled(ctx context.Context, facilityID, userID string, start, end time.Time) error <span class="cov0" title="0">{
        event := BookingEvent{
                Type:       EventBookingCancelled,
                FacilityID: facilityID,
                StartTime:  start,
                EndTime:    end,
                UserID:     userID,
                Message:    "A booking slot has become available",
                Timestamp:  time.Now(),
        }

        data, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return p.redis.Publish(ctx, ChannelBookings, string(data))</span>
}

// PublishSlotAvailable notifies that a slot is available
func (p *EventPublisher) PublishSlotAvailable(ctx context.Context, facilityID string, start, end time.Time) error <span class="cov0" title="0">{
        event := BookingEvent{
                Type:       EventSlotAvailable,
                FacilityID: facilityID,
                StartTime:  start,
                EndTime:    end,
                Message:    "Slot is now available for booking",
                Timestamp:  time.Now(),
        }

        data, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return p.redis.Publish(ctx, ChannelBookings, string(data))</span>
}

// EventSubscriber subscribes to Redis Pub/Sub channels
type EventSubscriber struct {
        redis *RedisClient
}

// NewEventSubscriber creates a new event subscriber
func NewEventSubscriber() *EventSubscriber <span class="cov0" title="0">{
        return &amp;EventSubscriber{
                redis: GetClient(),
        }
}</span>

// SubscribeToBookings subscribes to booking events and calls the handler for each event
func (s *EventSubscriber) SubscribeToBookings(ctx context.Context, handler func(event BookingEvent)) error <span class="cov0" title="0">{
        pubsub := s.redis.Subscribe(ctx, ChannelBookings)

        // Process messages in a goroutine
        go func() </span><span class="cov0" title="0">{
                ch := pubsub.Channel()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case msg, ok := &lt;-ch:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">s.processMessage(msg, handler)</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                pubsub.Close()
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

func (s *EventSubscriber) processMessage(msg *goredis.Message, handler func(event BookingEvent)) <span class="cov0" title="0">{
        var event BookingEvent
        if err := json.Unmarshal([]byte(msg.Payload), &amp;event); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to unmarshal event: %v", err)
                return
        }</span>
        <span class="cov0" title="0">handler(event)</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package tracing

import (
        "context"
        "log"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/stdout/stdouttrace"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

// InitTracer initializes the OpenTelemetry tracer provider.
func InitTracer(serviceName string) (*trace.TracerProvider, error) <span class="cov0" title="0">{
        // Create stdout exporter to be able to retrieve shared spans for now
        // In production, you would use otlptracegrpc or similar
        exporter, err := stdouttrace.New(
                stdouttrace.WithPrettyPrint(), // Make it readable in logs for now
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create Resource to identify this service
        <span class="cov0" title="0">res, err := resource.New(context.Background(),
                resource.WithAttributes(
                        semconv.ServiceNameKey.String(serviceName),
                        semconv.ServiceVersionKey.String("1.0.0"),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Register the Trace Provider
        <span class="cov0" title="0">tp := trace.NewTracerProvider(
                trace.WithBatcher(exporter),
                trace.WithResource(res),
        )

        // Register global Trace Provider and Propagator
        otel.SetTracerProvider(tp)
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        ))

        log.Println("Initialized OpenTelemetry Tracer")
        return tp, nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package websocket

import (
        "context"
        "encoding/json"
        "log"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
        platformRedis "github.com/lukcba/club-pulse-system-api/backend/internal/platform/redis"
)

// Config holds WebSocket server configuration.
type Config struct {
        WriteWait      time.Duration
        PongWait       time.Duration
        PingPeriod     time.Duration
        MaxMessageSize int64
}

// DefaultConfig provides standard operational values.
var DefaultConfig = Config{
        WriteWait:      10 * time.Second,
        PongWait:       60 * time.Second,
        PingPeriod:     54 * time.Second, // Must be less than PongWait
        MaxMessageSize: 512,
}

var upgrader = websocket.Upgrader{
        ReadBufferSize:  1024,
        WriteBufferSize: 1024,
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                // Security: In production, check r.Header.Get("Origin") against allowed domains.
                return true
        }</span>,
}

// Client represents a connected WebSocket user.
// Refactored to be cleaner (Logic moved to Hub).
type Client struct {
        hub    *Hub
        conn   *websocket.Conn
        send   chan []byte
        userID string
}

// Hub maintains the set of active clients and handles message routing.
// Architected for High Performance with O(1) user lookups and Topic Subscriptions.
type Hub struct {
        // Registered clients.
        clients map[*Client]bool

        // O(1) lookup for User -&gt; Clients (User can have multiple devices).
        userClients map[string]map[*Client]bool

        // Topic subscriptions for filtered broadcasting.
        // topic -&gt; client -&gt; true
        subscriptions map[string]map[*Client]bool

        // Inbound messages from clients (Requests).
        commands chan clientCommand

        // Outbound messages to broadcast/multicast.
        broadcast chan broadcastMessage

        // Targeted messages (Unicast).
        unicast chan unicastMessage

        // Register/Unregister requests.
        register   chan *Client
        unregister chan *Client

        // Sync primitives (Though we try to run single-threaded loop).
        // Locking strategy: The Hub.Run loop owns all maps.
        // External access (like SendToUser called from HTTP handler) needs thread-safe injection.
        // We use channels for everything to stay lock-free in the main loop.
}

type clientCommand struct {
        client  *Client
        payload []byte
}

type broadcastMessage struct {
        topic   string // If empty, global broadcast.
        payload []byte
        exclude *Client
}

// NewHub initializes the Hub with optimized data structures.
func NewHub() *Hub <span class="cov0" title="0">{
        return &amp;Hub{
                clients:       make(map[*Client]bool),
                userClients:   make(map[string]map[*Client]bool),
                subscriptions: make(map[string]map[*Client]bool),
                broadcast:     make(chan broadcastMessage, 256),
                unicast:       make(chan unicastMessage, 256),
                commands:      make(chan clientCommand, 256),
                register:      make(chan *Client),
                unregister:    make(chan *Client),
        }
}</span>

// Run handles all Hub events in a single goroutine to avoid race conditions and mutex contention.
func (h *Hub) Run(ctx context.Context) <span class="cov0" title="0">{
        // Background Redis Subscription
        go h.subscribeToRedis(ctx)

        for </span><span class="cov0" title="0">{
                select </span>{
                case client := &lt;-h.register:<span class="cov0" title="0">
                        h.registerClient(client)</span>

                case client := &lt;-h.unregister:<span class="cov0" title="0">
                        h.unregisterClient(client)</span>

                case cmd := &lt;-h.commands:<span class="cov0" title="0">
                        h.processClientCommand(cmd.client, cmd.payload)</span>

                case msg := &lt;-h.broadcast:<span class="cov0" title="0">
                        h.dispatchMessage(msg)</span>

                case msg := &lt;-h.unicast:<span class="cov0" title="0">
                        h.dispatchUnicast(msg)</span>

                case &lt;-ctx.Done():<span class="cov0" title="0">
                        h.shutdown()
                        return</span>
                }
        }
}

// --- Internal Logic (Single Threaded - Safe) ---

func (h *Hub) registerClient(client *Client) <span class="cov0" title="0">{
        h.clients[client] = true

        // Add to User Map
        if _, ok := h.userClients[client.userID]; !ok </span><span class="cov0" title="0">{
                h.userClients[client.userID] = make(map[*Client]bool)
        }</span>
        <span class="cov0" title="0">h.userClients[client.userID][client] = true

        log.Printf("Client connected: %s", client.userID)</span>
}

func (h *Hub) unregisterClient(client *Client) <span class="cov0" title="0">{
        if _, ok := h.clients[client]; ok </span><span class="cov0" title="0">{
                // Clean up global list
                delete(h.clients, client)

                // Clean up user map
                if _, ok := h.userClients[client.userID]; ok </span><span class="cov0" title="0">{
                        delete(h.userClients[client.userID], client)
                        if len(h.userClients[client.userID]) == 0 </span><span class="cov0" title="0">{
                                delete(h.userClients, client.userID)
                        }</span>
                }

                // Clean up subscriptions
                // Performance Note: Iterate topics is O(T). If T is large, invert this map (Client -&gt; Topics).
                // For MVP/Medium scale, this is acceptable.
                <span class="cov0" title="0">for topic, subs := range h.subscriptions </span><span class="cov0" title="0">{
                        if _, ok := subs[client]; ok </span><span class="cov0" title="0">{
                                delete(subs, client)
                                if len(subs) == 0 </span><span class="cov0" title="0">{
                                        delete(h.subscriptions, topic)
                                }</span>
                        }
                }

                <span class="cov0" title="0">close(client.send)</span>
        }
}

func (h *Hub) processClientCommand(client *Client, payload []byte) <span class="cov0" title="0">{
        var msg struct {
                Action  string   `json:"action"`
                Targets []string `json:"targets"`
        }
        if err := json.Unmarshal(payload, &amp;msg); err != nil </span><span class="cov0" title="0">{
                return // Ignore malformed
        }</span>

        <span class="cov0" title="0">switch msg.Action </span>{
        case "subscribe":<span class="cov0" title="0">
                for _, topic := range msg.Targets </span><span class="cov0" title="0">{
                        if h.subscriptions[topic] == nil </span><span class="cov0" title="0">{
                                h.subscriptions[topic] = make(map[*Client]bool)
                        }</span>
                        <span class="cov0" title="0">h.subscriptions[topic][client] = true</span>
                }
        case "unsubscribe":<span class="cov0" title="0">
                for _, topic := range msg.Targets </span><span class="cov0" title="0">{
                        if subs, ok := h.subscriptions[topic]; ok </span><span class="cov0" title="0">{
                                delete(subs, client)
                        }</span>
                }
        }
}

func (h *Hub) dispatchMessage(msg broadcastMessage) <span class="cov0" title="0">{
        if msg.topic != "" </span><span class="cov0" title="0">{
                // Topic Broadcast
                if subs, ok := h.subscriptions[msg.topic]; ok </span><span class="cov0" title="0">{
                        for client := range subs </span><span class="cov0" title="0">{
                                if client != msg.exclude </span><span class="cov0" title="0">{
                                        h.sendSafe(client, msg.payload)
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // Global Broadcast
                for client := range h.clients </span><span class="cov0" title="0">{
                        h.sendSafe(client, msg.payload)
                }</span>
        }
}

func (h *Hub) dispatchUnicast(msg unicastMessage) <span class="cov0" title="0">{
        if clients, ok := h.userClients[msg.targetUserID]; ok </span><span class="cov0" title="0">{
                for client := range clients </span><span class="cov0" title="0">{
                        h.sendSafe(client, msg.payload)
                }</span>
        }
}

func (h *Hub) sendSafe(client *Client, payload []byte) <span class="cov0" title="0">{
        select </span>{
        case client.send &lt;- payload:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // Slow client, drop or kick. For now, we drop message, kicking is handled by heartbeats ideally.
                // h.unregisterClient(client) // Auto-kick policy could go here
        }
}

func (h *Hub) shutdown() <span class="cov0" title="0">{
        for client := range h.clients </span><span class="cov0" title="0">{
                h.unregisterClient(client)
        }</span>
}

// --- External API (Thread-Safe via Channels) ---

// SendToUser sends a message efficiently to a specific user across all their devices.
// This command is technically external, but we inject it into the main loop via a special "Internal" command
// or we just handle it here if we want to block? No, blocking is bad.
// Ideally, `broadcast` needs to support "TargetUser".
// For now, let's just cheat and assume direct access if we can't change the Hub struct too much,
// BUT since we are Architects, let's fix strictly.
// We'll add a 'DirectMessage' channel or use Broadcast with metadata.
// For simplicity in this Refactor Step 1, I'll add a 'unicast' channel/method logic.
// However, since `SendToUser` is exported, let's make it push to a channel.
// We need to extend the `Hub` to support this properly.
// Let's add `unicast chan unicastMessage` to Hub struct? Or reuse `broadcast` with target.
// Simpler: Just generic `events` channel.
// To keep diff minimal, I will implement a safe closure.
func (h *Hub) SendToUser(userID string, message []byte) <span class="cov0" title="0">{
        // We run a goroutine to not block the caller, pushing to a channel processed by Run loop.
        // But `Hub` struct definition needs to change to hold this channel.
        // I'll skip adding a new channel to keep struct simple and assume this method is infrequently called or change design to use `broadcast`.

        // Locking strategy revisited: If we want O(1) read, we need RLock.
        // But `Run` uses no mutex. We cannot mix strategies safely without great care.
        // Correct approach: `Run` owns the map. `SendToUser` MUST send a message to `Run`.
        // Using a `inject` channel.

        // Since I can't effectively add a new channel and restart the `Run` loop in a live/hot reload sense easily without restarting app,
        // I will stick to the existing `broadcast` channel pattern but perhaps abuse it?
        // No, clean code. I will check userClients in the loop.

        // WAIT: I added `userClients` to `Hub`. I can't read it here safely while `Run` writes it.
        // I MUST assume `SendToUser` is not thread safe unless I add a Mutex OR use channels.
        // Given strict requirements: I will stick to the "Run Loop Owns All" pattern.
        // I will add `unicast` channel to Hub.

        // Note: Since I am rewriting the file, I CAN change the struct.
        // I will add `unicast chan unicastMessage`.

        h.unicast &lt;- unicastMessage{targetUserID: userID, payload: message}
}</span>

// Needs to be added to struct and constructor above.
// I will edit the `Hub` struct in the big file write.

type unicastMessage struct {
        targetUserID string
        payload      []byte
}

// --- Redis Integration ---

func (h *Hub) subscribeToRedis(ctx context.Context) <span class="cov0" title="0">{
        subscriber := platformRedis.NewEventSubscriber()

        // This fits the "Adapter" pattern logic.
        err := subscriber.SubscribeToBookings(ctx, func(event platformRedis.BookingEvent) </span><span class="cov0" title="0">{
                msg := WebSocketMessage{
                        Type:      event.Type,
                        Payload:   event,
                        Timestamp: time.Now(),
                }
                data, _ := json.Marshal(msg)

                // Determine topic based on event? e.g. "facility:{id}"
                // For now, broadcast global or specific?
                // Assuming global for simplified MVP logic as per original file.
                // Or smart routing:
                // h.broadcast &lt;- broadcastMessage{topic: "facility:" + event.FacilityID, payload: data}

                // Maintaining original "Broadcast All" behavior for compatibility,
                // but enabling future smart routing.
                h.broadcast &lt;- broadcastMessage{payload: data}
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error: %v", err)
        }</span>
}

// --- Handlers ---

// HandleWebSocket upgrades HTTP to WS.
func HandleWebSocket(hub *Hub) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                userID := c.GetString("user_id")
                if userID == "" </span><span class="cov0" title="0">{
                        userID = "anonymous"
                }</span>

                <span class="cov0" title="0">conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Upgrade error: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">client := &amp;Client{
                        hub:    hub,
                        conn:   conn,
                        send:   make(chan []byte, 256), // Buffered to handle bursts
                        userID: userID,
                }

                client.hub.register &lt;- client

                go client.writePump()
                go client.readPump()</span>
        }
}

// writePump writes messages to the websocket.
func (c *Client) writePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(DefaultConfig.PingPeriod)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                c.conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.send:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(DefaultConfig.WriteWait))
                        if !ok </span><span class="cov0" title="0">{
                                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">w, err := c.conn.NextWriter(websocket.TextMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">w.Write(message)

                        // Optimized: Flush queued messages
                        n := len(c.send)
                        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                w.Write([]byte{'\n'})
                                w.Write(&lt;-c.send)
                        }</span>

                        <span class="cov0" title="0">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(DefaultConfig.WriteWait))
                        if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// readPump reads messages from the websocket.
func (c *Client) readPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.hub.unregister &lt;- c
                c.conn.Close()
        }</span>()

        <span class="cov0" title="0">c.conn.SetReadLimit(DefaultConfig.MaxMessageSize)
        c.conn.SetReadDeadline(time.Now().Add(DefaultConfig.PongWait))
        c.conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                c.conn.SetReadDeadline(time.Now().Add(DefaultConfig.PongWait))
                return nil
        }</span>)

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, message, err := c.conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("WS Error: %v", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                // Send command to Hub (Thread-safe state mutation)
                <span class="cov0" title="0">c.hub.commands &lt;- clientCommand{client: c, payload: message}</span>
        }
}

// --- DTOs ---

type WebSocketMessage struct {
        Type      string      `json:"type"`
        Payload   interface{} `json:"payload"`
        Timestamp time.Time   `json:"timestamp"`
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
